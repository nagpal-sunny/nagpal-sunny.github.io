[
  
  {
    "title": "Game - Connect Balls",
    "url": "/posts/apps/apps-games-ConnectBall/",
    "categories": "Apps",
    "tags": "apps, game",
    "date": "2023-09-10 09:15:10 +0530",
    





    
    "snippet": "It is about:School time Memories are always there to cherish. Playing games on paper while the teacher is present in the classroom is what everyone remembers.  This was one of the games I played mo...",
    "content": "It is about:School time Memories are always there to cherish. Playing games on paper while the teacher is present in the classroom is what everyone remembers.  This was one of the games I played most of the time with friends. The game is simple yet engaging. You have to connect all the balls (dots on the paper) with a line. The line can be drawn with the use of a joystick.Let’s play all the levels and break the records !!!!.Download:Privacy Policy:Saurav Nagpal built the ConnectBalls app as a Free app. This SERVICE is provided by Saurav Nagpal at no cost and is intended for use as is.This page is used to inform visitors regarding my policies with the collection, use, and disclosure of Personal Information if anyone decided to use my Service.If you choose to use my Service, then you agree to the collection and use of information in relation to this policy. The Personal Information that I collect is used for providing and improving the Service. I will not use or share your information with anyone except as described in this Privacy Policy.The terms used in this Privacy Policy have the same meanings as in our Terms and Conditions, which are accessible at ConnectBalls unless otherwise defined in this Privacy Policy.Information Collection and UseFor a better experience, while using our Service, I may require you to provide us with certain personally identifiable information. The information that I request will be retained on your device and is not collected by me in any way.Log DataI want to inform you that whenever you use my Service, in a case of an error in the app I collect data and information (through third-party products) on your phone called Log Data. This Log Data may include information such as your device Internet Protocol (“IP”) address, device name, operating system version, the configuration of the app when utilizing my Service, the time and date of your use of the Service, and other statistics.CookiesCookies are files with a small amount of data that are commonly used as anonymous unique identifiers. These are sent to your browser from the websites that you visit and are stored on your device’s internal memory.This Service does not use these “cookies” explicitly. However, the app may use third-party code and libraries that use “cookies” to collect information and improve their services. You have the option to either accept or refuse these cookies and know when a cookie is being sent to your device. If you choose to refuse our cookies, you may not be able to use some portions of this Service.Service ProvidersI may employ third-party companies and individuals due to the following reasons:  To facilitate our Service;  To provide the Service on our behalf;  To perform Service-related services; or  To assist us in analyzing how our Service is used.I want to inform users of this Service that these third parties have access to their Personal Information. The reason is to perform the tasks assigned to them on our behalf. However, they are obligated not to disclose or use the information for any other purpose.SecurityI value your trust in providing us your Personal Information, thus we are striving to use commercially acceptable means of protecting it. But remember that no method of transmission over the internet, or method of electronic storage is 100% secure and reliable, and I cannot guarantee its absolute security.Links to Other SitesThis Service may contain links to other sites. If you click on a third-party link, you will be directed to that site. Note that these external sites are not operated by me. Therefore, I strongly advise you to review the Privacy Policy of these websites. I have no control over and assume no responsibility for the content, privacy policies, or practices of any third-party sites or services.Children’s PrivacyI do not knowingly collect personally identifiable information from children. I encourage all children to never submit any personally identifiable information through the Application and/or Services. I encourage parents and legal guardians to monitor their children’s Internet usage and to help enforce this Policy by instructing their children never to provide personally identifiable information through the Application and/or Services without their permission. If you have reason to believe that a child has provided personally identifiable information to us through the Application and/or Services, please contact us. You must also be at least 16 years of age to consent to the processing of your personally identifiable information in your country (in some countries we may allow your parent or guardian to do so on your behalf).Changes to This Privacy PolicyI may update our Privacy Policy from time to time. Thus, you are advised to review this page periodically for any changes. I will notify you of any changes by posting the new Privacy Policy on this page.This policy is effective as of 2023-09-10Contact UsIf you have any questions or suggestions about my Privacy Policy, do not hesitate to contact me at nagpalsaurav@gmail.com.This privacy policy page was created at privacypolicytemplate.net and modified/generated by App Privacy Policy Generator"
  },
  
  {
    "title": "Enum in Swift",
    "url": "/posts/ios/swift/enum-in-swift/",
    "categories": "iOS, Swift",
    "tags": "Enum, Swift Enum, Value Types In Swift",
    "date": "2023-07-15 14:22:00 +0530",
    





    
    "snippet": "    guard let category = attributes.filter({        if case .category(_) = $0 {            return true        }        return false    }).first, case .category(let categoryMask) = category  else { ...",
    "content": "    guard let category = attributes.filter({        if case .category(_) = $0 {            return true        }        return false    }).first, case .category(let categoryMask) = category  else {        return nil    }What is ARC?ARC is a memory management tool which tracks and manages the application memory. It is a compiler-driven feature. It observes the reference count of object of a class to manage and free the memory. So the question is what is reference count?Reference count in simple language is the “number of pointers to any object”.public typealias Amount = Intpublic class MyTravel {    public var city: String    public var totalSpending: Amount        public init(city: String, totalSpending: Int) {        self.city = city        self.totalSpending = totalSpending    }}//Uses of My Travel Class//My trip Listlet goaTrip = MyTravel(city: \"Panji\", totalSpending: 50000) //init is one pointer to Object ofprint(\"I spent Rs \\(goaTrip.totalSpending) in goa trip\")var tripWithHigherSpending = [goaTrip] // One more pointer to goaTripvar recentTrip = goaTrip              // One more pointer to goaTripprint(\"I spent Rs \\(recentTrip.totalSpending) during recentTrip\")Reference counting only applies to class instances, so struct &amp; enum do not participate in reference counting.How ARC Works?As mentioned, ARC is a compiler-driven feature. It inserts retain and release statements during compilation.  Retain increase the reference count.  Release decrease the reference count.#TechShortsARC is the compiler-driven feature and it injects retain/release statements in a code during compilation time.How does the compiler decide when to insert retain/release?  Object life cycle in Swift begins with init and ends at last use.ARC decide based on the above when to add retain and release statement.public typealias Amount = Intpublic class MyTravel {    public var city: String    public var totalSpending: Amount        public init(city: String, totalSpending: Int) {        self.city = city        self.totalSpending = totalSpending    }}The object life cycle in Swift is different from the other language. In most of the other languages, it ends at the closing brace.However, code should not be written based on this assumption and as it might change depending upon the compiler optimisation/changes.func explainARCSample() {    //My trip List    let goaTrip = MyTravel(city: \"Panji\", totalSpending: 50000)    weak var goaWeakTrip = goaTrip    var recentTrip = goaTrip    recentTrip.city = \"Manali\"    recentTrip.totalSpending = 40000        print(\"I used weak reference here: Goa Trip Rs \\(goaWeakTrip?.totalSpending ?? 50000) during recent trip\")}You should not write logic as written above as the result is unexpected in the above case.ARC need your help.ARC cannot detect or break **Reference cycle **. If object holds a strong reference to each other directly or indirectly in that case memory cannot be released of the objects.In the above cases, even if the compiler inserts a release statement the object will not be released from memory as both object holds each other.Prevention is the only cure here, so while writing code this need to take care of.Weak &amp; Unowned Reference CycleTo break the reference cycle weak and unowned keywords can be used. Both reference type does not participate in reference counting.public class MyTravelDiary {    fileprivate var travels: [MyTravel]    public init() {        self.travels = []    }        public func addTravel(_ travel: MyTravel) {        self.travels.append(travel)    }}Weak reference can be used when you are not sure about the life cycle of the referred object. It will automatically be set to nil if the object reference count becomes zero. The only constraint with weak is must be optional.public class MyTravel {    public var city: String    public var totalSpending: Amount    weak var travelDiary: MyTravelDiary?        public init(city: String, totalSpending: Int) {        self.city = city        self.totalSpending = totalSpending    }}Unowned reference can be used when you are sure about the life cycle of the referred object and it will not be deallocated. It can be used with an object which has an equal or greater life cycle. Unowned references can be declared as non-optional and faster access as compared to weak ones. The weak need to unwrap to access the value.public class MyTravel {    public var city: String    public var totalSpending: Amount    unowned var travelDiary: MyTravelDiary        public init(city: String, totalSpending: Int, travelDiary: MyTravelDiary) {        self.city = city        self.totalSpending = totalSpending        self.travelDiary = travelDiary    }}let travelDiary = MyTravelDiary()//unowned useslet manaliTrip = MyTravel(city: \"Manali\", totalSpending: 40000, travelDiary: travelDiary)//weak useslet manaliTrip = MyTravel(city: \"Manali\", totalSpending: 40000)manaliTrip.travelDiary = travelDiary#TechShortsA weak reference is automatically set to nil if no strong reference remains and a weak reference is always optional. Unowned references will refer to deallocated memory if no strong reference remains, so the application can crash. Unowned is always non-optional.Bonus.There are safe ways to access the weak refrence to avoid unexpected result or fatal excpetion (force unrawp) at run time.public class MyTravel {    public var city: String    public var totalSpending: Amount    public weak var travelDiary: MyTravelDiary?        public var isExistInTravelDiary: Bool {        return self.travelDiary!.travels.filter {            $0.city == self.city        }.first != nil    }        public init(city: String, totalSpending: Int) {        self.city = city        self.totalSpending = totalSpending    }}public class MyTravelDiary {    fileprivate var travels: [MyTravel]    public init() {        self.travels = []    }        public func addTravel(_ travel: MyTravel) {        self.travels.append(travel)    }}Option 1: withExtendedLifetimefunc testTravelDiary() {    //Manali Trip    let travelDiary = MyTravelDiary()    let manaliTrip = MyTravel(city: \"Manali\", totalSpending: 40000)    manaliTrip.travelDiary = travelDiary        withExtendedLifetime(travelDiary) {        let existString = manaliTrip.isExistInTravelDiary ? \"exist\" : \"not exist\"        print(\"Manali Travel \\(existString) in Travel Diary\")    }}Option 2: Strong Reference Capturepublic var isExistInTravelDiary: Bool {     if let travelDiary = self.travelDiary {           return travelDiary.travels.filter{                $0.city == self.city            }.first != nil      }      return false }"
  },
  
  {
    "title": "ARC in Swift",
    "url": "/posts/ios/ios%20memory%20management/arc-in-swift/",
    "categories": "iOS, iOS Memory Management",
    "tags": "ARC, Swift ARC",
    "date": "2023-07-15 14:22:00 +0530",
    





    
    "snippet": "One of the key factors for the success of any application is its performance. Effective Memory Management in an application is crucial for better performance of the application. iOS applications de...",
    "content": "One of the key factors for the success of any application is its performance. Effective Memory Management in an application is crucial for better performance of the application. iOS applications developed using Swift language rely on ARC for tracking and managing application memory usage. ARC uses reference counting to manage the application memory.What is ARC?ARC is a memory management tool which tracks and manages the application memory. It is a compiler-driven feature. It observes the reference count of an object of a class to manage and free the memory. So the question is what is reference count?Reference count in simple language is the “number of pointers to any object”.  public typealias Amount = Int  public class Trip {    public var city: String    public var totalSpending: Amount        public init(city: String, totalSpending: Int) {        self.city = city        self.totalSpending = totalSpending    }  }  //Uses of Trip Class  let goaTrip = Trip(city: \"Panji\", totalSpending: 50000) //init is one pointer to Object of  print(\"I spent Rs \\(goaTrip.totalSpending) in goa trip\")    var tripToBeach = [goaTrip] // One more pointer to goaTrip  var recentTrip = goaTrip              // One more pointer to goaTrip  print(\"I spent Rs \\(recentTrip.totalSpending) during recentTrip\")Reference counting only applies to class instances, so struct &amp; enum do not participate in reference counting.How ARC Works?As mentioned, ARC is a compiler-driven feature. It inserts retain and release statements during compilation.  Retain - increase the reference count.  Release - decrease the reference count.#TechShortsARC is the compiler-driven feature and it injects retain/release statements in a code during compilation time.How does the compiler decide when to insert retain/release?  Object life cycle in Swift begins with init and ends at last use.ARC decide based on the above when to add retain and release statement.  public typealias Amount = Int  public class Trip {    public var city: String    public var totalSpending: Amount        public init(city: String, totalSpending: Int) {        self.city = city        self.totalSpending = totalSpending    }  }The object life cycle in Swift is different from the other language. In most of the other languages, it ends at the closing brace.However, code should not be written based on this assumption as it might change with future compiler changes. For example, the following code is a good example of a team nightmare that suddenly a working code stopped.  func explainWrongAssumptionUses() {    //My trip List    let goaTrip = Trip(city: \"Panji\", totalSpending: 50000)    weak var weakRefrenceToGoaTrip = goaTrip        if let strongRefrenceToGoaTrip =  weakRefrenceToGoaTrip {        print(\"I used weak reference here: Goa Trip Rs \\(strongRefrenceToGoaTrip.totalSpending)     during the recent trip\")    }  }In the above case, it is wrong to assume that goaWeakTrip will always be there. The last use of the object is weak var weakRefrenceToGoaTrip = goaTrip and the compiler will insert release after this statement.So print statement here totally depends upon how the compiler works. if an Object’s life cycle in Swift begins with init and ends at last use. is strictly followed by the compiler then 50000 is the result. In the future, due to some drawbacks of this approach, Apple decided the scope based on the brace start and end then the result will be different.ARC need your help.ARC cannot detect or break **Reference cycle **. If object holds a strong reference to each other directly or indirectly in that case memory cannot be released of the objects.In the Direct case, the Trip and TravelDiary objects are strongly held together. Therefore, releasing one object requires the release of the other object as well. We can break the reference cycle here by making reference weak in the Trip object for the TravelDiary.In the Indirect case, the Person object is strongly held TravelDiary Object. TravelDiary strongly holds the trip object and further Trip holds the person object strongly. Therefore, releasing an Object in this scenario requires other two objects should be released. We can break the reference cycle here by keeping Person Object in the Trip object weak.Weak &amp; Unowned Reference CycleTo break the reference cycle weak and unowned keywords can be used. Both reference type does not participate in reference counting.  public class TravelDiary {    fileprivate var travels: [Trip]    public init() {        self.travels = []    }        public func addTravel(_ travel: Trip) {        self.travels.append(travel)    }  }Weak reference can be used when you are not sure about the life cycle of the referred object. It will automatically be set to nil if the object reference count becomes zero. The only constraint with weak is must be optional.  public class Trip {    public var city: String    public var totalSpending: Amount    public weak var travelDiary: TravelDiary?            public init(city: String, totalSpending: Int) {        self.city = city        self.totalSpending = totalSpending    } }Unowned reference can be used when you are sure about the life cycle of the referred object and it will not be deallocated. It can be used with an object which has an equal or greater life cycle. Unowned references can be declared as non-optional and faster access as compared to weak ones. The weak need to unwrap to access the value.  public class Trip {    public var city: String    public var totalSpending: Amount    public weak var travelDiary: TravelDiary?            public init(city: String, totalSpending: Int) {        self.city = city        self.totalSpending = totalSpending    } }  let travelDiary = TravelDiary()  //unowned uses  let manaliTrip = Trip(city: \"Manali\", totalSpending: 40000, travelDiary: travelDiary)  //weak uses  let manaliTrip = Trip(city: \"Manali\", totalSpending: 40000)  manaliTrip.travelDiary = travelDiary#TechShortsA weak reference is automatically set to nil if no strong reference remains and a weak reference is always optional. Unowned references will refer to deallocated memory if no strong reference remains, so the application can crash. Unowned is always non-optional.Bonus.There are safe ways to access the weak reference to avoid unexpected results or fatal exceptions (force unwrap) at run time.  public class Trip {    public var city: String    public var totalSpending: Amount    public weak var travelDiary: TravelDiary?        public var isExistInTravelDiary: Bool {        if let travelDiary = self.travelDiary {            return travelDiary.travels.filter{                $0.city == self.city            }.first != nil        }        return false    }        public init(city: String, totalSpending: Int) {        self.city = city        self.totalSpending = totalSpending    }  }   public class TravelDiary {    fileprivate var travels: [Trip]    public init() {        self.travels = []    }        public func addTravel(_ travel: Trip) {        self.travels.append(travel)    }  }Option 1: withExtendedLifetime  func prepareTravelDiary() {    //Manali Trip    let travelDiary = TravelDiary()    let manaliTrip = Trip(city: \"Manali\", totalSpending: 40000)    manaliTrip.travelDiary = travelDiary        travelDiary.addTravel(manaliTrip)        withExtendedLifetime(travelDiary) {        let existString = manaliTrip.isExistInTravelDiary ? \"exist\": \"not exist\"        print(\"Manali Travel \\(existString) in Travel Diary\")    }  }Option 2: Strong Reference Capture  func prepareStrongTravelDiary() {    //Manali Trip    let travelDiary = TravelDiary()    let manaliTrip = Trip(city: \"Manali\", totalSpending: 40000)    manaliTrip.travelDiary = travelDiary        travelDiary.addTravel(manaliTrip)    processTrip(manaliTrip)  }  func processTrip(_ trip: Trip) {    //somewhere in code in other method    if let travelDiary = trip.travelDiary {        let existString = trip.isExistInTravelDiary ? \"exist\" : \"not exist\"        print(\"\\(trip.city) Travel \\(existString) in Travel Diary\")    }  }"
  },
  
  {
    "title": "Distribute iOS Beta Build (Scheme & Configurations)",
    "url": "/posts/ios/ios%20beta%20build/iOS-Custom-Build-Scheme/",
    "categories": "iOS, iOS Beta Build",
    "tags": "iOS scheme, iOS build config",
    "date": "2023-07-02 17:01:10 +0530",
    





    
    "snippet": "🌑 OutlineHaving multiple build configurations during the application’s development phase is a good practice. Customers can ask for both debug and release configuration builds. Beta and Alpha testin...",
    "content": "🌑 OutlineHaving multiple build configurations during the application’s development phase is a good practice. Customers can ask for both debug and release configuration builds. Beta and Alpha testing is an important phase of the application life cycle. Beta and Alpha builds might have different configurations from the release build. This blog explains one of the ways to handle this through an Xcode scheme.🌥️ Why SchemeSuppose you are working on an e-commerce application ShopTime. In the development phase, multiple backend environments need to support (Dev, QA, UAT, Release). The customer provides separate application icons to differentiate between the application build (Development, QA, Beta builds, etc.). These builds also have a unique bundle ID. The launch screens should also be different for each build so that users can easily identify the build.  Configuration can support multiple features however for this blog we will focus on the following:      Bundle Identifier    App Icon    Launch Screen    Backend URL  🌓 How To CreateXcode supports multiple configurations in a single target. By default, Xcode provides debug and release configuration. Let’s start step by step the process:Step 1  Add a new configuration (Beta configuration)i) Navigate to the project settingii) Tap on the “+” button in the configuration section and duplicate the debug configuration(you can choose duplicate of release based on requirement).iii) Enter the name of the configuration (BetaDebug). Step 2 Change product bundleid for BetaDebugi) Move to Target-&gt; Build Setting-&gt; Search(Product Bundle Identifier)ii) Set the bundle identifier as per your requirement.Step 3 Set separate application icon for BetaDebugi) Add a new AppIcon asset in Assets with a specific name(AppIconBeta).ii) Add AppIconBeta in the BetaDebug configuration.iii) Finally!, a separate application icon is set for BetaDebug.Step 4 Set separate Launch screen for BetaDebugi) Add a new launch screen for Beta config. ii) Edit launch screen configuration for BetaDebug.iii) Finally!, a separate Launch screen is set for BetaDebug.Step 5 Add a user setting for the backend URLi) Word up  Add a new user-defined setting in the target setting. ii) Name the configuration “Backend_URL”(choose your own name) and change the URL string for BetaConfig.iii) Add the entry in info.plist for the backend URL.iv) Fetch the user-defined setting in the code.if let urlString = Bundle.main.object(forInfoDictionaryKey: \"Backend URL\") as? String {    print(urlString)}🌕 Where to use⚡ It can be used to handle code signing variation in the application build type like beta build, ad-hoc build, test build, etc. Each scheme will represent a building type. ⚡ It can be used to add configurations with respect to builds like backend URLs, API keys, etc.🌚 Facts⚡ Application Target is different from the scheme. A target may have multiple schemes. A target can be used to make variants of the application like pro features (No ads, offers)."
  },
  
  {
    "title": "Design Pattern Series: Decorator Pattern (Structure Pattern)",
    "url": "/posts/design%20pattern/clean%20code/decoratorpattern/",
    "categories": "Design Pattern, Clean Code",
    "tags": "Decorator Pattern, Class Wrapper",
    "date": "2023-06-24 20:00:10 +0530",
    





    
    "snippet": " Overview Decorator Pattern - Decorate an object (wrapper of an object).The decorator pattern is used to add new functionality to an existing object without changing its structure. A wrapper on the...",
    "content": " Overview Decorator Pattern - Decorate an object (wrapper of an object).The decorator pattern is used to add new functionality to an existing object without changing its structure. A wrapper on the existing object is created to add new functionality. Problem StatementOne day I woke up and as per my daily routine attended the daily scrum parallelly checking the customer email.  As usual a new requirement (part of Agile :)) was asked by the customer to add one more analytic tool to the application. We already integrated Firebase analytic tool into the application. The reason mentioned by the customer to add a new analytic tool is that it provides good support with their BI Tool.Now I sit with the team and check the current implementation. The current structure has an analytics event controller class which accepts an event object and sends the same to the google analytics framework.One quick common approach all the team members have is to add support for Adobe Analytics in the Analytic controller, so when the developer sends analytics from any screen it will by default capture both frameworks (Firebase, Adobe Analytics).With this approach, the Analytic Controller code will become bloated. If there is a new requirement to add a new type of analytics, then it will not be easy to accommodate in the controller.We brainstormed more on this to save ourselves and future team members and then the decorator came into the picture. ImplementationThe decorator pattern uses an interface/protocol(Swift) with the composition.Code SnippetAn analytic event is a struct which will hold an analytic event and Analytic Delegate is protocol.struct AnalyticEvent {    let eventName: String    var eventDetail: [String: String]}protocol AnalyticDelegate {    func sendEvent(_ event: AnalyticEvent)}//Firebase Analyticsimport Firebaseclass AnalyticController: AnalyticDelegate {    init() {        FirebaseApp.configure()    }        func sendEvent(_ event: AnalyticEvent) {        Analytics.logEvent(event.eventName, parameters:event.eventDetail)    }}//Class Implementation before Decoratorclass AddToCartController {    let analyticDelegate: AnalyticDelegate        init(analyticDelegate: AnalyticDelegate = AnalyticController()) {        self.analyticDelegate = analyticDelegate    }        func startPayment(for product: Product, paymentMethod: SupportedPaymentFacade) {        let paymentInfo = PaymentInfo(skuID: product.skuID, amount: product.amount, method: paymentMethod)        facade.doPayment(paymentInfo)    }}//Decorator class implement the Adobe Analytics and delegate firebase event to the existing controller.class AnalyticControllerDecorator: AnalyticDelegate {    let analyticDelegate: AnalyticDelegate    init(analyticDelegate: AnalyticDelegate = AnalyticController()) {        self.analyticDelegate = analyticDelegate    }        func sendEvent(_ event: AnalyticEvent) {        MobileCore.track(action: event.eventName, data: event.eventDetail)        self.analyticDelegate.logEvent(event.eventName, parameters:event.eventDetail)    }}//Class Implementation before Decoratorclass AddToCartController {    let analyticDelegate: AnalyticDelegate        init(analyticDelegate: AnalyticDelegate = AnalyticController()) {        self.analyticDelegate = analyticDelegate    }        func startPayment(for product: Product, paymentMethod: SupportedPaymentFacade) {        let paymentInfo = PaymentInfo(skuID: product.skuID, amount: product.amount, method: paymentMethod)        facade.doPayment(paymentInfo)    }}//Uses with or without Decoratorvar controllerWithFirebaseAnalytic =  AddToCartController(AnalyticController())var controllerWithFirebaseAnalytic =  AddToCartController(AnalyticControllerDecorator()) Applicability    Use the decorator when you need to add additional behaviour to an existing object without impacting the current uses of the object.The decorator object and main objects share a common interface so both can be used interchangeably. In this way, existing applications can use additional business requirements with minimal changes.     Additional behaviour requires on the final class without changing anything on an existing object.The decorator object and main objects share a common interface so both can be used interchangeably. In this way, existing applications can use additional business requirements with minimal changes. FactsInheritance vs Decorator    The decorator can be used on different objects which share a common interface. However, inheritance only works for similar kinds of objects.    Classes with final behaviour. In those cases, inheritance is not possible. so we can use a decorator pattern to add additional behaviour.    Decorator is applicable to only a single object of a class. However, inheritance is applicable to the entire class.    Use inheritance when you need additional behaviour on non-public members of the class.Adapter vs Decorator    An adapter pattern also holds an object and provides a simplified interface (familiar Interface) to the outer world for that object.    Adapter Object does not provide an additional behaviour on the object.    In the case of the adapter, the client (who calls the method) does not aware of the object interface. It only knows the Adapter interface."
  },
  
  {
    "title": "Design Pattern Series: Facade Pattern (Structure Pattern)",
    "url": "/posts/design%20pattern/clean%20code/Facadepattern/",
    "categories": "Design Pattern, Clean Code",
    "tags": "Facade Pattern, Face of a building",
    "date": "2023-06-24 20:00:10 +0530",
    





    
    "snippet": " Overview Facade - Face of a building.A pattern to provide a simple interface to a complex framework or library. It hides the complexity and interaction between different objects in the framework. ...",
    "content": " Overview Facade - Face of a building.A pattern to provide a simple interface to a complex framework or library. It hides the complexity and interaction between different objects in the framework. Problem StatementSuppose you are working on an e-commerce application. You have to support multiple payment options like UPI, Credit card, Debit Card, Wallet etc. You have chosen a third-party payment gateway which provides support for all types of payments. The payment gateway has an initiation setup (API key, session) and multiple objects for payment methods.If you write all the logic in your application class then your class object require to manage all the payment objects and track the life cycle of those objects. In this way, your code will be tightly depend upon third-party payment SDK.To make things simple we can use here Facade Design Pattern. ImplementationIn the Facade pattern, a class is created to provide a simple interface for a complex system.Code Snippet//Enum to identify payment type.enum SupportedPaymentFacade {    case wallet    case upi    case card}//Payment Information.struct PaymentInfo {    let skuID: String    let amount: Int    let method: SupportedPaymentFacade}// sample class which represent the complex third party frameworkclass PaymentSDKUmbrella {    let walletSDK: PSWallet    let upiSDK: PSUPI    let cardSDK: PSCard}// Facade class application interact with this object. Application will not aware about PaymentSDKUmbrella.class PaymentFacade {    var paymentSDKUmbrella: PaymentSDKUmbrella?    func doPayment(_ paymentInfo: PaymentInfo) {        switch paymentInfo.method {        case .card:            cardSDK.doPayment(paymentInfo.amount)        case .upi:            upi.doPayment(paymentInfo.amount)        case .wallet:            if walletSDK.hasSufficientAmount(paymentInfo.amount) {                walletSDK.doPayment(paymentInfo.amount)            } else {                print(\"Insufficient balance\")                walletSDK.addPayment(paymentInfo.amount)            }        }    }}//Application uses of facade classclass AppPaymentController {    let facade = PaymentFacade()        func startPayment(for product: Product, paymentMethod: SupportedPaymentFacade) {        let paymentInfo = PaymentInfo(skuID: product.skuID, amount: product.amount, method: paymentMethod)        facade.doPayment(paymentInfo)    }} ApplicabilityComplex LibraryIntegrating a library which has multiple subsystems can be done through the facade pattern. Also, if the library is used at multiple places then to avoid the redundant code of init and setup the library facade can be used.  In the above example, payment SDK has multiple sub-systems like wallet, net banking and Card payment. So you can create a facade class in a way that your application has minimal knowledge of all the dependencies of the payment SDK.Small InterfacesUse a facade pattern when you want to use limited functionality from a complex library.  In the case of payment SDK, if you want to use only wallet and card payment in your application then you can create a facade class to support only those features. FactsAdapter vs Facade Pattern    The facade provides a new interface to interact with a complex framework. However, the adapter fits the new object in the existing interface.    An adapter or wrapper pattern is usually for a single object. However, Facade also interacts with multiple objects.Mediator vs Facade Pattern    The mediator class is used for providing the interaction between sub-components. However, the facade class is used for providing access (simple interface) to sub-components of a large component.    In the case of the mediator, sub-components are aware of the mediator class but the facade class is only visible to the application using sub-components. AdvantagesYou must have been feeling now that the use of the facade pattern is just that the responsibility of interaction to complex system is shifted to facade class. DecouplingIt is always considered good practice that your application code should not directly depend upon the third-party library interface. Facade patterns provide a simple interface to a complex framework, in a way you also achieve decoupling here.  Like in the above case your application code depends upon the Facade class, so if in the future library code changes then only the Facade class will be impacted.ReusabilityIn some use cases, the same library needs to be used from multiple places. Like in the above case payment can be done from multiple screens, so instead of the user accessing the library code at each screen the facade class can be used which also reduces the library setup/init burden at every place.ReadabilityMost of the time library/framework code is legacy code. Coding convention changes from time to time and the library interface might not fit your current coding convention, So the facade can be used to make code consistent in your application."
  },
  
  {
    "title": "Design Pattern Series: Template Pattern (Behaviour Pattern)",
    "url": "/posts/design%20pattern/clean%20code/templatepattern/",
    "categories": "Design Pattern, Clean Code",
    "tags": "Template Pattern, Template Method",
    "date": "2023-06-24 20:00:10 +0530",
    





    
    "snippet": "🌑 OutlineThe Template pattern declares/defines a structure for a process/algorithm in a superclass and the subclass can override specific steps of an algorithm to provide desired behaviour without ...",
    "content": "🌑 OutlineThe Template pattern declares/defines a structure for a process/algorithm in a superclass and the subclass can override specific steps of an algorithm to provide desired behaviour without changing the execution flow of the process. The method/function that decides the execution sequence of a process/algorithm is called the Template method.  Template - A structure/pattern to be followed for an algorithm/process.🌥️ Why TemplateWhile writing code sometimes you might get into a situation where a standard set of steps to be performed to achieve the functionality. The easy option is to call these steps one by one at the required place. This way the desired functionality will be achieved however, the process is not standardised and not reusable.For example, you are working on a news reader application. To display the news in the application a standard set of steps needs to be followed:  Fetch the news from the source.  parse the news feed.  Categories the news (Entertainment, Top News etc.).  Filter the duplicate news.  Sort the categories &amp; news based on timestamp.Intially you have written a code that only supports XML. After 6 months of development, a new JSON-based feed source needs to be supported. From the above steps, the impact is only on the parsing step.One basic approach will be at parsing time you will check if the response is XML then parse XML else parse JSON. This will work but this is not a scalable and easily maintained solution. If more response types need to be supported then more conditions and more change in existing class.Another approach will be a Template method for getting the Feeds from the source.🌛 = 🌜 MetaphorTemplate patterns can be related to a car assembly. A Car assembly has a sequence of steps in the following order: designing, Fit Car Body, Fit car chassis, Fit Car Engine, Fit Car Door.Each step, such as designing, fitting a chassis, and fitting a car engine can be slightly changed based on the type of car but the sequence of steps will be the same.🌓 How it looks⚡ Define an Abstract class or interface⚡ Define a default class by implementing the interface.⚡ Define a template method in the default class. Implementation will contain the sequence of steps to be followed.⚡ If any variant is required then make a new variant class derived from default class.Code SnippetA Feed instance.struct Feed {    var title: String    var description: String    var category: String}protocol FeedReader {    var feeds: [Feed] { get }        func fetchFeeds() async -&gt; [String: String]    func parseFeeds(rawFeeds: [String: String])    func categorizeFeeds(feeds: [Feed]) -&gt; [Feed]    func filterDuplicate(feeds: [Feed]) -&gt; [Feed]    func sortFeeds(feeds: [Feed]) -&gt; [Feed]        func startFeedReader() async}class DefaultFeedReader: FeedReader {    var feeds: [Feed] = []        //Template Method    func startFeedReader() async {        let rawFeeds = await self.fetchFeeds()        self.parseFeeds(rawFeeds: rawFeeds)        let categorizeFeeds = self.categorizeFeeds(feeds: self.feeds)        let filterFeeds = self.filterDuplicate(feeds: categorizeFeeds)        let sortFeeds = self.sortFeeds(feeds: categorizeFeeds)                self.feeds = sortFeeds    }        //Template methods    func fetchFeeds() async -&gt; [String: String] {        //Logic for fetch feed    }        func parseFeeds(rawFeeds: [String : String]) {        //Logic for general parse    }        func categorizeFeeds(feeds: [Feed]) -&gt; [Feed] {        //Logic for categorize parse    }        func filterDuplicate(feeds: [Feed]) -&gt; [Feed] {        //Logic for filter    }        func sortFeeds(feeds: [Feed]) -&gt; [Feed] {        //Logic for sort feeds    }}class JsonFeedReader: DefaultFeedReader {    override func parseFeeds(rawFeeds: [String : String]) {        //Logic for  parse JSON    }}🌕 Applicability⚡ It can be applied when you are implementing an algorithm/process which has a standard sequence of steps to follow. Example: Compiler designing.⚡ When multiple variants with minor changes require an algorithm/process. An algorithm/process that supports multiple data types can be a good candidate for a template pattern.Example: parsing (XML/JSON/txt), upload data (image/Xml/txt). So most of the steps will be the same only the handling of data will be changed.  In most of the applications login/sign-up process has a set of steps which can be fit in the template method. The authentication may have variants like (PIN/ FACEId/ Touch ID). Steps before and after authentication will not be affected by the authentication method (PIN/ FACEId/ Touch ID).✨ Trade-offsReusability vs FlexibilityTemplate pattern supports code reusability by moving common code in the base class. On the other hand, It creates a rigid hierarchy of classes. You cannot change the flow and steps in the derived class. For example, In the above case, a new car requires the solar panel to be set up on the roof to support an electric battery which is not possible in the current template. There is no step in the process to add a Panel on the rooftop. You need to change the base class for this.Cohesion vs CouplingTemplate pattern helps to achieve cohesion in a code by grouping similar functionality in a single place. In the above case, getting feed for the application is at a single place and no dependency will exist on another module to get feeds if structure followed. However, on the other hand, it creates a tight coupling between the base class and the subclasses. Any change in the base class will impact the derived class. While designing the base class you need to take care of the interface it should not be too fat.🌚 FactsTemplate &amp; FactoryThe Template method may look like the Factory pattern as both have similar designs. However, the Factory pattern is a creational pattern and abstracts the creation logic of similar kinds of objects. On the other hand, a Template pattern is a behavioural design pattern which defines the behaviour of the process.  Question: A template pattern which defines the behaviour of the creation of similar types of Objects can be called a Factory?Answer: Still, the Template pattern here helps to define the behaviour of the creation of an object not initialize an object for another module. The creation responsibility of the object is still outside of the template method.Template &amp; StrategyThe template method is used when a standard/common behaviour exists for an algorithm/process. The common behaviour defined in the base class and variants in a process/algorithm can be added in the subclass.Strategy pattern is also used to handle multiple variants of an algorithm/Process. However, each variant has independent (No common) implementation. Sorting in most of the language is implemented through this pattern."
  },
  
  {
    "title": "Flutter on Apple Silicon Mac: Cocoa-pods Issue",
    "url": "/posts/crossplatform/flutter/crossplatform-Flutter-on-Apple-Silicon-Mac/",
    "categories": "CrossPlatform, Flutter",
    "tags": "Mac rosetta, Mac M1",
    "date": "2023-06-22 09:15:10 +0530",
    





    
    "snippet": "Step 1:Flutter requires the rosette must be installed on your machine. Rosetta is a translation library which allows users to run apps that contain X86_64 instructions on Apple silicon Mac.sudo sof...",
    "content": "Step 1:Flutter requires the rosette must be installed on your machine. Rosetta is a translation library which allows users to run apps that contain X86_64 instructions on Apple silicon Mac.sudo softwareupdate --install-rosetta --agree-to-licenseStep 2:Cocoa-pods require a terminal using UTF-8 encoding.  Sometimes only setting “LANG=en_US.UTF-8” not works. you need to perform the following steps:  Open Terminal  nano ~/.zshrc (\"or nano ~/.profile if you don't use zsh\")  Apeen the following in the editor:export LANG=en_US.UTF-8export LANGUAGE=en_US.UTF-8export LC_ALL=en_US.UTF-8  Save the file and quit the terminal.  Open the file again and verify.Step 3 (Optional)if you still see an error related to “ffi” then reinstall the gem “ffi” in the system with the following command.sudo gem uninstall ffi &amp;&amp; sudo gem install ffi -- --enable-libffi-alloc"
  },
  
  {
    "title": "Swift ?? (Nil Coalescing) Do's and Don't",
    "url": "/posts/swift/swift%20safety/Swift-(Nil-Coalescing)-Do's-and-Don't/",
    "categories": "Swift, Swift Safety",
    "tags": "Swift optional, Swift Nil Coalescing",
    "date": "2023-06-21 02:24:10 +0530",
    





    
    "snippet": "What is it?Optional is one of the fundamental safety features provided in Swift. It is a container for a value of a particular type. We are using the term container here because it means it may con...",
    "content": "What is it?Optional is one of the fundamental safety features provided in Swift. It is a container for a value of a particular type. We are using the term container here because it means it may contain a value or not. Nil coalescing ?? is an operator used to provide a default if the optional is empty.How to use it?Add default value after the ??  operator following Optional. var name: String? let displayName = name ?? \"NA\" print(\"name is:\\(displayName)\")In this case, if the name is not available then “name is NA” will be printed. In Swift, we need to always take care while unwrapping an Optional as it might crash the application. The Nil coalescing ?? operator does the Job for you if it finds the optional has no value then it uses a default instead.Do’s and Don’t with ?? (#My Opinion)Following are some of the uses I have seen in the code and we go through them one by one and discuss the case:(i) Requirement is if Name is not present then display “NA” var name: String? let displayName = name ?? \"NA\" print(\"name is:\\(displayName)\")(ii) Requirement is to get number of rows in the selected section    func indexPathOfTableView() {        var selectedIndexPath: IndexPath?        //Assing a value in code somewhere        selectedIndexPath = IndexPath(section: 1, row: 0)                //Uses of the indexPath        tableView?.numberOfRows(inSection: selectedIndexPath?.section ?? 0)    }(iii) Requirement is to fetch a random student from the list    func randomStudent() {        var randomStudent: Student?        //Assign Value to the random student in code                //Somewhere in code        let selectedStudent = randomStudent ?? Student()        if selectedStudent.name.count &gt; 0 {        }    }(iv) Requirement is to fetch all student names.    struct Student {        var name: String    }        func fetchAllNames() {        var students: [Student]?        //All student Name        let studentNames = students?.map { $0.name ?? \"\" }        print(\"All Student Names:\\(studentNames)\")    }(v) Requirement is to check if the student list exists or not.   func checkStudentExist() -&gt; Bool {        var students: [Student]?        //check student exist        if students?.count ?? 0 &gt; 0 {            return true        }        return false    }My Opinion(i) Do - It is correct usage as we provide the default value if it does not exist.(ii) Don’t - 0 is not the default value for the section and it also can cause an unexpected issue If the index path in any case nil.(ii) Don’t - In this case, a student object without referring to any student is not a correct usage it is not a default value. It can cause an issue or crash if you are expecting a real object and get this value.(iv) Don’t - The requirement is to fetch all names of a student and in case the student does not exist in the record then you should not assign a default value like “”. Either you have some agreed default value or raise an exception name not exist.(v) Don’t - The requirement is to check if the student list exists or not. In the case of the, if students?.count ?? 0 &gt; 0 condition using the default value is reducing the condition. However, in my opinion, it reduces the readability."
  },
  
  {
    "title": "Game - Save Trees",
    "url": "/posts/apps/apps-games-SaveTrees/",
    "categories": "Apps",
    "tags": "Game, Apps",
    "date": "2022-08-22 09:15:10 +0530",
    





    
    "snippet": "It is about:Our earth’s temperature is rising day by day. It is time to save the earth and reduce the effects of global warming. Start with this game and reduce global warming by saving the trees.L...",
    "content": "It is about:Our earth’s temperature is rising day by day. It is time to save the earth and reduce the effects of global warming. Start with this game and reduce global warming by saving the trees.Lumberjacks will come to cut the trees, you need to protect the trees by digging a hole in the way of lumberjacks. You can buy products from the nursery to ease your mission to save the earth.Download:"
  }
  
]

