[ { "title": "SwiftUI - Observed vs State Object", "url": "/posts/ios/swiftui/ObservedvsStateObject/", "categories": "iOS, SwiftUI", "tags": "ObservedObject, StateObject", "date": "2024-05-27 14:25:00 +0530", "snippet": "One of the main features of reactive programming is observable objects. SwiftUI provides the feel of reactive programming by property wrappers like StateObject and ObservedObject. Both property wra...", "content": "One of the main features of reactive programming is observable objects. SwiftUI provides the feel of reactive programming by property wrappers like StateObject and ObservedObject. Both property wrappers notify the SwiftUI View of any state change.Confusion is about which one to use at a given time. Let‚Äôs check the basics first.BasicsStateObject &amp; ObservedObject require conformance to the ObservableObject protocol. It (ObservableObject) is a type with a publisher that emits before an object has been changed. Only the reference type (Class) can implement this because the tracking state change behaviour was impossible with the value type.Till now it seems both have similar behaviour. Let‚Äôs try to use one by one in an application.üåì Talk is cheap. Show me the codeSuppose you are travelling in a bus and sitting on the window seat. You started to count trees on the roadside. A favourite time passed in childhood. I have difficulty remembering numbers, so I created a small application:It has two components: TreeCounterViewModel - An ObservableObject hold the number and updates the view. TreeCounterView - Display the total count.@ObservedObjectclass TreeCounterViewModel: ObservableObject { @Published var treeCount = 0 func addTree() { self.treeCount += 1 }}The treeCount being @Published property forces the view to redraw.struct TreeCounterView: View { @ObservedObject var viewModel = TreeCounterViewModel() var body: some View { VStack(spacing: 20) { Text(\"Number of Trees: \\(self.$viewModel.treeCount.wrappedValue)\") Button(\"Add Trees\") { self.viewModel.addTree() } } }}The result is here:@StateObjectLet‚Äôs try to change the ViewModel to a @StateObject.struct TreeCounterView: View { @StateObject var viewModel = TreeCounterViewModel() var body: some View { VStack(spacing: 20) { Text(\"Number of Trees: \\(self.$viewModel.treeCount.wrappedValue)\") Button(\"Add Trees\") { self.viewModel.addTree() } } }}Oh, No difference in the result:In both cases, Tree Counter is working as expected. So why two property wrappers with the same behaviour?I thought to enhance the application by capturing total travel time.When to use State ObjectSo, In the application one new component has been added: TravelTimePassView - Start &amp; display the time elapsed in travel, also give an option to count trees i.e. TreeCounterView is added as a child.struct TravelTimePassView: View { @State private var timer = Timer.publish(every: 1, on: .main, in: .common) @State private var timerCancel: Cancellable! @State private var timeElapsed: TimeInterval = 0 var body: some View { VStack(spacing: 20) { Text(\"Travel Time Elapsed: \\(self.$timeElapsed.wrappedValue)\") HStack (spacing: 20) { Button(\"Start Travel\") { self.startTravelTime() } Button(\"Travel Complete\", action: { self.travelComplete() }) } Spacer().frame(height: 40) TreeCounterView() // Init Tree Counter View }.onReceive(timer) { _ in self.timeElapsed += 1 } } fileprivate func startTravelTime() { self.timerCancel?.cancel() self.timer = Timer.publish(every: 1, on: .main, in: .common) self.timerCancel = self.timer.connect() } fileprivate func travelComplete() { self.timerCancel?.cancel() self.timeElapsed = 0 }} Timer I have used a timer which will trigger every second. It will start by pressing the Start Travel button and stop by pressing the Travel Complete button. Timer Cancel A variable to hold timer cancellable type and it stops the running timer. Time Elapsed I used a counter to count the total seconds that elapsed from the timer‚Äôs start. TreeCounterView You can observe in the body of TravelTimePassView that TreeCounterView is initiated every time the body renders.Now let‚Äôs try TreeCounterView again with View Model property wrapper @StateObject &amp; ObservedObject. @StateObject var viewModel @ObservedObject var viewModel Now we can see the difference clearly, So SwiftUI manages the lifecycle differently for State &amp; Observed Object.If the Observed Object is initiated within view then it will be reinitialized when the view is recreated. On the other hand, State Object is unchanged on recreation of view.üåì Wind UpWhen a SwiftUI view needs to react to changes in data managed by an existing object (often a view model) that‚Äôs created and controlled outside the view hierarchy then @observedObject property wrapper can be used. In short, it should only be used through Dependency Injection.Use @StateObject to ensure consistent results after View Redraw. However, if the same state object needs to be passed to subsequent views, it should be marked as @observedObject in subsequent Views.Thanks for reading! I‚Äôd love to hear your thoughts on this article :)." }, { "title": "John's Interview - Loader Design", "url": "/posts/system%20design/architecture/Design-Mobile-App-Loader/", "categories": "System Design, Architecture", "tags": "Architecture, Design Pattern", "date": "2024-04-30 09:22:00 +0530", "snippet": "üåë OutlineJohn went for an iOS Interview at TechForGood Organization, which has a system design round. Let‚Äôs go through the transcript of the discussion. Interviewer: SteveCandidate: JohnSteve: Desi...", "content": "üåë OutlineJohn went for an iOS Interview at TechForGood Organization, which has a system design round. Let‚Äôs go through the transcript of the discussion. Interviewer: SteveCandidate: JohnSteve: Design a loader for a mobile application. It can be accessed anywhere within the application.Let‚Äôs check whether John clarifies all the requirements or jumps to the solutionüå•Ô∏è Clear Out RequirementSo John already knew the rules for the interview and started to ask questions.Let‚Äôs read what John clarified:John: Do we need to design a general-purpose library or part of an application source code?Steve: A Library.John: How does the Loader look like? Do we need to support multiple types of Loading UISteve: For now only circular arc Loader but the solution should be extendable to support multiple Loader UI.John: should the Loader have any opaque background?Steve: Yes, it should support both with or without background.John: Should the loader support a timer?Steve: What do you mean by timer?John: A timer to auto-stop the Loader after some time?Steve: No, not required for now.John sums up the requirement in short: A Loader library must be designed to support multiple loading activity types. For now, circular activity support is required. The loader should be flexible to support a background.üåì SolutionThis is John‚Äôs time ‚è≥ to think about the design.After thinking for 10 minutes, the following is a high-level design by John:High-Level DesignComponents:1. LoaderViewThe library‚Äôs main UI component handles the request to show and hide the loader. It is also responsible for adding background if required.2. ActivityHeart of the library and responsible for the layout of the loader with animation.3. ShapeAn interface to represent various shapes for the loader. For example, an Arc Shape is required to implement a circular arc loader.3. AnimationAn interface to represent animation on the activity. For the given problem, a rotation animation struct will implement this.Steve wants to go further. so he asks for a public interface for the library.Public Interfacepublic enum loaderActivityType: Int { case circleArcLoader}public init(type: loaderActivityType = .circleArcLoader)func showLoader(inView: View)func hideLoader()Steve: Do I need to initialise the loader on every screen?John: Yes, I designed it in a way that wherever the loader needs to be displayed a new instance should be created, An alternative approach can be a singleton class to construct a loader. However, I Intentionally keep this design so that developers using the library have the flexibility to add a singleton adapter or create multiple instances as per requirement.Steve: The showLoader method requires a view as an input parameter. can you think of any approach to using the view as an optional func showLoader(inView: View? = nil) ?John: A parent view is required to display the loader. We can use the application‚Äôs main window(iOS) to display the loader if the view is optional and not present. I like the approach of passing a view from the invoking method because accessing the main window from the library might have an unexpected behaviour in case the application has multiple windows.Steve: is the hideLoader method have a mechanism to check if the loader is visible and then only hide?John: No, I have not thought of this case, however, I can use some flag to keep the state of the loader.Detail DesignSteve gets an overview of the approach next, he wants to discuss in detail all the components of the library. He started with the Animation component:Animation In-DepthSteve: Would you explain how the Animation component works?John: This component provides add animation to the activity. For example, a circular loader has a circle that rotates infinitely. The animation component will provide infinite rotation animation.Steve: How Activity component interact with Animation?John: The Animation component will have a standard interface for all the possible animations for the Loader. In future when any animation needs to be added they adhere to the standard interface.John: Can I use paper to explain the idea? Steve: SureJohn:protocol LoaderAnimation { func addAnimationOnView(_ view: View)}struct InfiniteRotationAnimation: LoaderAnimation {\tfunc addAnimationOnView(_ view: View) { //Rotate Animation implementation }}The activity component can create an instance of ‚ÄúInfiniteRotationAnimation‚Äù and apply it on the view wherever required.Steve: Great. Let‚Äôs move to the Shape component.Shape In-DepthSteve: What the Shape component do?John: This component provides the shapes required for the loader. The shape can be a dot, circle, or anything required for the loader.Steve: How is it used in the library?John: The shape component will have a standard interface named Shape. Activity can ask for any shapeprotocol Shape: View { func setupShape()}struct CircleShape: Shape { func setupShape() { }}Steve: What if multiple shapes are required in a loader?John: The activity role comes here, It is responsible for the init and layout of all shapes required for the loader.Steve: ok, let‚Äôs discuss the Activity then.Activity In-DepthSteve: What does this activity component do?John: This component is the heart of the library. It assembles the shapes required for the Loader with animation.Steve: What do you mean by Assembles here?John: Suppose a developer wants a Loader with a circle arc rotating in the centre clockwise. A Circle Arc activity component asks for a circle shape from the shape component and adds clockwise animation on the circle shape.Steve: So an activity represents a loader type?John: Yes, to support a Loader type respective activity type needs to be created. Like a Circle Arc Activity for a circular loader, pulse Activity for a circle pulse loader, etc. Circle Arc Activity Pulse Activity Steve: Can you scribble the interface for Activity?John:protocol ActivityIndicator where Self: UIView { var isAnimating: Bool { get set } var hideWhenStop: Bool { get set } func startAnimating() func stopAnimating()}class CircleArcActivityIndicatorView: View, ActivityIndicator { //Implementation of Circular Arc rotating animation}class CirclePulseActivityIndicatorView: View, ActivityIndicator { //Implementation of Circular Pulse animation}Loader In-DepthSteve: What is this Loader component?John: This provides the public interface which we discussed earlier.Steve: ok, John I am done and Thanks for coming here for discussion.John has a secret here that he already worked on the Loader library and it is here üòâ" }, { "title": "SwiftUI - Fixed vs Dynamic Size Spacer", "url": "/posts/ios/swiftui/Fixed_Size_Spacer/", "categories": "iOS, SwiftUI", "tags": "Spacer, Fixed Size Spacer", "date": "2024-04-23 11:22:00 +0530", "snippet": "A spacer is an element that adds space between two components. If it is inside a stack layout then it expands along the stack axis else expands in both directions.Fixed Size SpacerSpacer is also a ...", "content": "A spacer is an element that adds space between two components. If it is inside a stack layout then it expands along the stack axis else expands in both directions.Fixed Size SpacerSpacer is also a SwiftUI component and behaves similarly, So apply a frame modifier to set the height or width of Spacer.VStack {\tText(\"Before Spacer\") Spacer().frame(height: 20) Text(\"After Spacer\")}Dynamic Size SpacerImagine you‚Äôre building a layout with buttons. If you want to make sure the buttons have at least minimum space but can be distant based on available space then here is the minLength parameter:VStack {\tText(\"Before Spacer\") Spacer(minLength: 20) Text(\"After Spacer\")}If you want to provide a range for the space length then the frame modifier needs to apply in the way .frame(minHeight: 20, maxHeight: 80)" }, { "title": "Namaste Swift Server", "url": "/posts/swift/vapor/NamasteSwiftServer/", "categories": "Swift, Vapor", "tags": "Server Side Swift, Swift", "date": "2024-04-15 11:30:00 +0530", "snippet": "üåë OutlineSwift has gained significant traction since its launch in 2014. Currently, it‚Äôs ranked as the 8th most in-demand language to learn. While many associate Swift with iOS and Mac development,...", "content": "üåë OutlineSwift has gained significant traction since its launch in 2014. Currently, it‚Äôs ranked as the 8th most in-demand language to learn. While many associate Swift with iOS and Mac development, its open-sourcing in 2015 unlocked new possibilities. One exciting area is server-side development, which we‚Äôll immersed in today.We will use the Vapor Web framework to implement the HTTP web service in Swift. We will try to implement a simple login service with Vapor.üåì Talk is cheap. Show me the codeTo use Vapor on macOS, please ensure you have Swift 5.6 or greater.Instal Vapor on macOSThe Vapor is available through Homebrew only. if you already have a Homebrew setup then run the following command.brew install vaporTo set up Homebrew please visit the linkCreate a Vapor ProjectOnce Vapor is installed run the following command to create a new project.vapor new NamasteSwiftServer -n -n flag for the bare minimum project. if you want to use ORM or any other setting then avoid this.You can create a project through the Xcode SPM option also, however, to set up a minimal project will also take some effort.Run Template ServerOpen the project in Xcode and run the application.Congratulations! Your server is running at the following path:[ NOTICE ] Server starting on http://127.0.0.1:8080If you want to change port or API then open the configure.swift file.// configures your applicationpublic func configure(_ app: Application) async throws { // register routes\tapp.http.server.configuration.hostname = \"127.0.0.1\" app.http.server.configuration.port = Int(Environment.get(\"PORT\") ?? \"8081\" ) ?? 8081 try routes(app)} Sometimes it may happen that a specific IP address cannot be assigned to the application due to a system firewall restriction or any other cause, so choose wisely.Login ServiceNavigate to the routes.swift file and you can write your login logic in the following way:app.get(\"auth\") { req async -&gt; LoginResponse in let username: String? = req.query[\"username\"] let userpwd: String? = req.query[\"password\"] if username == \"admin\" &amp;&amp; userpwd == \"testadmin\" { return LoginResponse(isSuccess: true, error: [:]) } return LoginResponse(isSuccess: false, error: [\"Login_001\": \"Inavlid Username &amp; Password\"]) } get An HTTP Method to get the data. You can use any HTTP method based on your requirements. auth It is a part of the request‚Äôs URI. http://127.0.0.1:8080/auth req An object of the Request class contains all the request details like headers, request \tquery, body etc.üåï Time to test serverOnce again run the application in Xcode. Open the browser and type the URL: http://127.0.0.1:8080/auth?username=admin&amp;password=testadminThe response is:{\"error\":{},\"isSuccess\":true}Now type with invalid username &amp; password:{\"isSuccess\":false,\"error\":{\"Login_001\":\"Inavlid Username &amp; Password\"}}Congratulations! You have a server up and running.üåö ConclusionYou can find the source code here.Try it!, one of the major use cases can be to Mock the API for Mobile Testing apart from completely writing the server in Swift." }, { "title": "Case 001 - AnyView kills Performance", "url": "/posts/ios/swiftui/anyview_impact-_performance/", "categories": "iOS, SwiftUI", "tags": "SwiftUI, Anyview, Performance", "date": "2024-03-01 18:22:00 +0530", "snippet": "üìã Case DetailRecently, I was working on an application and looking for a solution to dynamically return a view from a method.The scenario was that TabBar children could be returned dynamically from...", "content": "üìã Case DetailRecently, I was working on an application and looking for a solution to dynamically return a view from a method.The scenario was that TabBar children could be returned dynamically from a method.func viewForTabItem(_ coordinator: any ASTabItemView, isSelected: Bool) -&gt; AnyViewObserve that the method takes attributes for tab items (image, text) and returns respective views.There are various ways to achieve this: @ViewBuilder‚Ä¶some View. Return a Protocol containing a view. AnyViewWhile looking for the solution, I came up with multiple sources where it is mentioned that avoid AnyView.Sources:WWDC NotesDeveloper ForumCurious about why AnyView should be avoided, I landed on Apple Documentation: An AnyView allows changing the view type used in a given hierarchy. Whenever the type of view used with an AnyView changes, the old hierarchy is destroyed and a new hierarchy is created for the new type.This seems to be a reason for all the discussion going on and from the above definition, introducing AnyView in the hierarchy will have a heavy toll on UI rendering.Then decided to investigate the case and evaluate AnyView.üïµÔ∏è‚Äç‚ôÇÔ∏è Suspect InterrogationWe already identified the suspect based on the reasons: Apple Documentation. Open Discussion on various forumsNow to understand in detail, let‚Äôs compare the output of return type with &amp; without AnyView.Concrete Type:func normalTextWithoutAnyView() -&gt; VStack&lt;Text&gt; { VStack { Text(\"Normal Text\") }}Output:Return the type of ‚ÄúVStack with layout description and detail of Text‚Äù with storage.Type Erased:func wrapTextInAnyView() -&gt; AnyView { AnyView(VStack { Text(\"Wrap Text In AnyView\") })}Output:Here return the type of ‚ÄúAnyView‚Äù containing storage of type AnyViewStorage&lt;VStack&gt;. Not much detail is printed.Observation is at runtime there is extra effort to figure out what is hidden inside the AnyView. Also, it stops the compiler from resolving the view hierarchy at compile time.Let‚Äôs try to record the data when AnyView attacks the performance using instruments.üöß Reconstruct Crime SceneTo evaluate performance first we should have the right kind of setup. In this case, I am creating a Grid View that will render the Type of Grid Child element.struct GridView&lt;cell: GridChild&gt;: View { var rowCount: Int var columnCount: Int var itemSize: CGSize\tlet update: Binding&lt;Bool&gt; var body: some View { return GeometryReader { proxy in ZStack { Grid { ForEach((1...rowCount), id: \\.self) { rowNumber in self.gridRow(rowNumber: rowNumber) } } } } } @ViewBuilder func gridRow(rowNumber: Int) -&gt; some View { GridRow { ForEach((1...columnCount), id: \\.self) { columnNumber in let indexPath = IndexPath(row: rowNumber, section: columnNumber) cell(indexPath: indexPath, size: self.itemSize) } } }}This is a blueprint of the child of the Grid View.protocol GridChild: View { var indexPath: IndexPath { get } var itemSize: CGSize { get } init(indexPath: IndexPath, size: CGSize)}To find out the proof, let‚Äôs analyze the impact of the following scenarios using the above Grid View: Static N Text with and without Type Erased Dynamic view changes with and without AnyView(1-level Hierarchy) Dynamic view changes with and without AnyView(n-level Hierarchy)Static N Text with and without Type ErasedI chose to draw 210(row = 30, column = 7) cells in the Grid View that have only text.VStack(spacing: 10) { GridView&lt;TextChild&gt;(rowCount: 30, columnCount: 7, itemSize: textSize, update:$contentUpdater.isChange)}Grid Cell is made up of a simple Text object in the first case.struct TextChild: GridChild { var indexPath: IndexPath var itemSize: CGSize init(indexPath: IndexPath, size: CGSize) { self.indexPath = indexPath self.itemSize = size } var body: some View { Text(\"cell\\(indexPath.row)\\(indexPath.section)\").frame(width: itemSize.width, height: itemSize.height) }}In the second case, the Text used in the cell with Type Erased.VStack(spacing: 10) { GridView&lt;TypeErassedTextChild&gt;(rowCount: 30, columnCount: 7, itemSize: textSize, update: $contentUpdater.isChange)}struct TypeErassedTextChild: GridChild { var indexPath: IndexPath var itemSize: CGSize init(indexPath: IndexPath, size: CGSize) { self.indexPath = indexPath self.itemSize = size } var body: some View { AnyView(Text(\"cell\\(indexPath.row)\\(indexPath.section)\").frame(width: itemSize.width, height: itemSize.height)) }}Evidence CollectedTo capture the performance correctly the Grid is updated after 1 second of application launch.In the case of TypeErased(AnyView), one cycle of rendering is on the tiny higher side. If you observe the below images rendering with TypeErased has taken more microseconds. Concrete Type Erased However, it is a minuscule difference. Let‚Äôs analyze the impact when content is changing frequently.Dynamic view changes with and without AnyView(1-level Hierarchy)SwiftUI will only update the view if any change in the state is observed, So a timer is used to trigger the state change.class ContentUpdater: ObservableObject { private var timer: Timer? @Published var isChange: Bool = false init() { timer = Timer.scheduledTimer( withTimeInterval: 0.05, repeats: true ) { [weak self] _ in self?.isChange.toggle() } }}In the first case, Text or Image is the direct child of Grid View depending upon the state (contentUpdater.isChange).VStack(spacing: 10) { GridView&lt;ConditionTextNImageChild&gt;(rowCount: 30, columnCount: 7, itemSize: textSize, update: $contentUpdater.isChange)}The grid cell is made up of either Text or image depending upon a bool value.struct ConditionTextNImageChild: GridChild { var indexPath: IndexPath var itemSize: CGSize let shouldUpdate: Binding&lt;Bool&gt; init(indexPath: IndexPath, size: CGSize, shouldUpdate: Binding&lt;Bool&gt;) { self.indexPath = indexPath self.itemSize = size self.shouldUpdate = shouldUpdate } var body: some View { if self.shouldUpdate.wrappedValue { Text(\"cell\\(indexPath.row)\\(indexPath.section)\").frame(width: itemSize.width, height: itemSize.height) } else { Image(systemName: \"heart.fill\") } }}In the following case, AnyView is used to hide the Type.struct ConditionTypeErassedChild: GridChild { var indexPath: IndexPath var itemSize: CGSize let shouldUpdate: Binding&lt;Bool&gt; init(indexPath: IndexPath, size: CGSize, shouldUpdate: Binding&lt;Bool&gt;) { self.indexPath = indexPath self.itemSize = size self.shouldUpdate = shouldUpdate } var body: some View { if self.shouldUpdate.wrappedValue { AnyView(Text(\"cell\\(indexPath.row)\\(indexPath.section)\").frame(width: itemSize.width, height: itemSize.height)) } else { AnyView(Image(systemName: \"heart.fill\")) } }}Evidence CollectedThe timer frequency to refresh the content is set to 50ms so that performance can be evaluated under high stress.I recorded the SwitUI redraw behaviour for one minute and the results are the following: Concrete Type Erased Again concrete type has marginally won over AnyView. Observe the number of redrawn content View 1201 is higher than 1189. The average duration to draw the view is also less in the case of concrete.Now Let‚Äôs add more stress by adding hierarchy in Content View.View changes with AnyView(n-level Hierarchy)It‚Äôs the final stage of the investigation. Now Grid View is a child of HStack and Hstack is further than Zstack (3-level of hierarchy).ZStack { HStack { GridView&lt;ConditionTypeErassedChild&gt;(rowCount: 30, columnCount: 7, itemSize: textSize, update: $contentUpdater.isChange) }}Grid Cell is the same as in the case of the 1-level hierarchy.Evidence CollectedIn terms of the frequency of content updates, it is the same 50ms. Here again, I record the SwitUI redraw behaviour for one minute.In the case of Concrete Type, the average duration(11.22Œºs) to render the Content is better compared to TypeErased(11.67Œºs). Again concrete type is marginally win over AnyView. Concrete Type Erased ‚öñÔ∏è Closing StatmentWe observe that AnyView has a microscopic impact on the performance. This impact should not raise the fear of avoiding AnyView in the application. We also observed that the system needs to re-calculate the hierarchy in both cases with or without TypeErased.Time for Judgment(My Opinion), AnyView does not commit any heinous crime here, so there is no reason to censure it from use.The source code for the project can be found here." }, { "title": "What's System Design", "url": "/posts/system%20design/architecture/What's-System-Design/", "categories": "System Design, Architecture", "tags": "Architecture, Design Pattern", "date": "2024-01-01 09:22:00 +0530", "snippet": "üåë OutlineA common discussion in any team before starting any mobile application is which architecture should be followed. The discussion starts with the latest architecture trends and slowly reache...", "content": "üåë OutlineA common discussion in any team before starting any mobile application is which architecture should be followed. The discussion starts with the latest architecture trends and slowly reaches to what is the best architecture for mobile applications. Before discussing best architecture let‚Äôs discuss ‚Äúwhat is architecture?‚Äùüå•Ô∏è What is an Application ArchitectureThe architecture word was used even before software development existed. The root of the word is from the Greek ‚ÄúArchitekten‚Äù (‚Äúmaster builder‚Äù). Greeks are famous for making beautiful buildings üèõÔ∏è and a person who knows the art of designing buildings is a master builder.In software development, an architect is one who knows the art of software design and software architecture represents the design decisions related to overall system structure and behaviour. However, Design patterns like MVVM, VIPER, MVP, etc also become synonyms to architecture.Application architecture exposes the system‚Äôs structure and the components‚Äô behaviour. Can these Architecture patterns expose the complete structure of the application?Let‚Äôs suppose two applications follow the same VIPER pattern. Can I say both have the same Architecture? NO There is something more to add to understand the complete Architecture of an application that is System Design Application architecture can be defined as Architecture Pattern Plus System Design.üåì System DesignSystem design is the process of designing the elements of a system such as architecture, modules &amp; components. Also, interfaces of those components &amp; data flow through the system.Let‚Äôs go through these elements:ArchitectureIt is a diagram representing the application structure including all major components and their interaction. Modules A module represents a single piece of functionality of the application. A combination of modules makes the application. For example: login module. Components A component represents a reusable and replaceable component of an application. They are designed as independent with well-defined interfaces and can be used in multiple applications. For example: Network Framework, Database Framework Wrapper, etc. Interfaces In an application, Modules need to interact with each other to achieve functionalities and an interface provides a link for communication between two modules. For Example: A Login interface may contain a method ‚Äúloginuser‚Äù which accepts the parameters username and password. Any other module calls this method to perform login in the application. Data Define the data flow within the application.üåï How To DesignThere is no thumb rule to design an application. However, In my opinion, while designing any application, the following points need to be considered Decomposition Nobody wants to write a complete application within a single file. Modern Frameworks also provide support to split the application into multiple parts. For example: The iOS Framework will create a separate View Controller file for each View.Decomposition is breaking the application into smaller modules and components. You can further break a module into small modules like a login module can have login service, login view, etc. You can break even login View or service into small parts. Login View - &gt; (Login Input View, Forgot View, Reset Password View, Biometric View). Abstraction In simple terms, Abstraction in system design is defined as, How much a module should know the details of other modules or components. Abstraction is hiding the complexity of the module and just exposing what is needed. For example: you have a database manager who handles the data in the system and it only exposes the method to fetch and save the data without exposing where it saves and how it saves.Interfaces are key for the abstraction. All the Modern language has the support of interfaces. Developers can design a system so that modules and components depend upon each other interface rather than a concrete class.Abstraction can provide a lens to view the whole system without knowing the implementation complexity. Dependency Injection A component or module may have multiple dependencies, the only struggle is how to inject those dependencies into the module. One simple way is to access the dependencies within the module directly. For Example, the user profile module depends on the database component to save the user information. One way is to create a database manager object within the profile module and then use it. This might be an easy way, however, with this approach, you cannot test the module with a dummy database, also in case, the database is not properly initiated then the profile view cannot handle it.üåö Example: Cache System DesignDesign a cache system for a mobile application to save API responses. The cache saves the data in JSON format. The cache should be cleared after 2 days. Cache Manager An object to handle the cache read/write request. Any third-party application that wants to use this cache framework must request data from this object. Cache Record An object to maintain metadata about the cache. Cache Manager will interact with this object to check the validity of the cache. It will keep the name, location, size, created at, etc metadata for cache files. Persistent Storage An object to maintain file storage for cache response. Cache response will be stored in JSON files in the system." }, { "title": "SwiftUI - Create Expandable List (Section Approach)", "url": "/posts/ios/swiftui/Expandable-list/", "categories": "iOS, SwiftUI", "tags": "SwiftUI List, List", "date": "2023-09-26 11:22:00 +0530", "snippet": "üåë OutlineList View in Swift UI has the capability to support expandable lists without writing any extra logic for expansion or collapse. The section in a list can serve as the main cell and the cel...", "content": "üåë OutlineList View in Swift UI has the capability to support expandable lists without writing any extra logic for expansion or collapse. The section in a list can serve as the main cell and the cell can serve as the expended cell.Unlike UIKit, SwiftUI List View adjusts automatically based on the data source. No need to reload or delete cells just provide the expected format data and it will create the UI for you. List View has an initializer with a section which can be used here to set up an expandable list.üåì Talk is cheap. Show me the code‚ö° Create a protocol to represent a cell Item.‚ö° Create a model class for the main category implementing cell item.‚ö° Create a model class for the child category implementing cell item.‚ö° Main category model should contain child categories as an array of objects //Cell Itempublic protocol MenuItem: Identifiable { var id: UUID { get } var title: String { get } var image: String? { get } var childs: [any MenuItem]? { get }} //Main Categorypublic struct Organization: MenuItem { public var id = UUID() var name: String public var image: String? var products: [Product]? public var title: String { return name } public var childs: [any MenuItem]? { return self.products }}//Child Categorypublic struct Product: MenuItem { public var id = UUID() var name: String public var image: String? public var title: String { return name } public var childs: [any MenuItem]? { return nil }}//Create List Viewpublic struct ExpandableList: View { public var listItems: [any MenuItem] = [] public init() { setupListItems() } fileprivate mutating func setupListItems() { // setup Employee List let product1 = Product(name: \"iPhone\", image: \"iphone.gen1.circle\") let product2 = Product(name: \"Apple Watch\", image: \"watchface.applewatch.case\") let product3 = Product(name: \"iPad\", image:\"ipad.gen2\") let product4 = Product(name: \"Pixel Phone\", image: \"candybarphone\") let product5 = Product(name: \"Galaxy Phone\", image: \"flipphone\") let product6 = Product(name: \"Galaxy Watch\", image: \"stopwatch\") let product7 = Product(name: \"Smart Ring\", image: \"ring.circle\") let product8 = Product(name: \"Airdopes 131\", image: \"airpods\") // setup Department let AppleOrg = Organization(name: \"Apple\", products: [product1, product2, product3]) let googleOrg = Organization(name: \"Google\", products: [product4]) let samsungOrg = Organization(name: \"Samsung\", products: [product5, product6]) let boatOrg = Organization(name: \"Boat\", products: [product7, product8]) self.listItems = [AppleOrg, googleOrg, samsungOrg, boatOrg] } public var body: some View { List(self.listItems, id: \\.id, children: \\.childs) { item in HStack { if let image = item.image { Image(systemName: image) .frame(width: 35, height: 35) } Text(item.title) .font(.system(.title3, design: .rounded)) .bold() } } }}Download Complete Source Code: Expandable Listüåï How it LooksNote: A jerk is observed with iOS 16.4 SDK in the list." }, { "title": "Simplify Template Pattern (Behaviour Pattern)", "url": "/posts/design%20pattern/clean%20code/templatepattern/", "categories": "Design Pattern, Clean Code", "tags": "Template Pattern, Template Method", "date": "2023-09-20 20:00:10 +0530", "snippet": "üåë OutlineThe Template pattern defines steps for an algorithm in a superclass and a subclass can override specific steps to provide desired behaviour without changing the execution flow of the algor...", "content": "üåë OutlineThe Template pattern defines steps for an algorithm in a superclass and a subclass can override specific steps to provide desired behaviour without changing the execution flow of the algorithm. The function that decides the execution sequence of an algorithm is called the Template method. Template - A structure to be followed for an algorithm.üå•Ô∏è Why TemplateWhile writing code sometimes you might get into a situation where a standard set of steps to be performed to achieve the functionality. The easy option is to call these steps one by one at the required place. This way the desired functionality will be achieved however, the process is not standardised and not reusable.For example, you are working on a news reader application. To display the news in the application a standard set of steps needs to be followed: Fetch the news from the source. parse the news feed. Categories the news (Entertainment, Top News etc.). Filter the duplicate news. Sort the categories &amp; news based on timestamp.Intially you have written a code that only supports XML. After 6 months of development, a new JSON-based feed source needs to be supported. From the above steps, the impact is only on the parsing step.One basic approach will be at parsing time you will check if the response is XML then parse XML else parse JSON. This will work but this is not a scalable and easily maintained solution. If more response types need to be supported then more conditions and more change in existing class.Another approach will be a Template method for getting the Feeds from the source.üåõ = üåú MetaphorPizza making process can be related to the Template method. Overall steps for the process will remain the same it is just that you can modify a step slightly to make a special Pizza for you.To make an extra cheese pizza you can modify the ‚Äúadd cheese‚Äù step and the extra cheese pizza is ready.üåì Talk is cheap. Show me the code‚ö° Define an Abstract class or interface‚ö° Define a default class by implementing the interface.‚ö° Define a template method in the default class. Implementation will contain the sequence of steps to be followed.‚ö° If any variant is required then make a new variant class derived from the default class.Code SnippetA Feed instance.struct Feed { var title: String var description: String var category: String}protocol FeedReader { var feeds: [Feed] { get } func fetchFeeds() async -&gt; [String: String] func parseFeeds(rawFeeds: [String: String]) func categorizeFeeds(feeds: [Feed]) -&gt; [Feed] func filterDuplicate(feeds: [Feed]) -&gt; [Feed] func sortFeeds(feeds: [Feed]) -&gt; [Feed] func startFeedReader() async}class DefaultFeedReader: FeedReader { var feeds: [Feed] = [] //Template Method func startFeedReader() async { let rawFeeds = await self.fetchFeeds() self.parseFeeds(rawFeeds: rawFeeds) let categorizeFeeds = self.categorizeFeeds(feeds: self.feeds) let filterFeeds = self.filterDuplicate(feeds: categorizeFeeds) let sortFeeds = self.sortFeeds(feeds: categorizeFeeds) self.feeds = sortFeeds } //Template methods func fetchFeeds() async -&gt; [String: String] { //Logic for fetch feed } func parseFeeds(rawFeeds: [String : String]) { //Logic for general parse } func categorizeFeeds(feeds: [Feed]) -&gt; [Feed] { //Logic for categorize parse } func filterDuplicate(feeds: [Feed]) -&gt; [Feed] { //Logic for filter } func sortFeeds(feeds: [Feed]) -&gt; [Feed] { //Logic for sort feeds }}class JsonFeedReader: DefaultFeedReader { override func parseFeeds(rawFeeds: [String : String]) { //Logic for parse JSON }}üåï Applicability‚ö° It can be applied when you are implementing a process which has a standard sequence of steps to follow. Example: Compiler designing.‚ö° A functionality which supports multiple types of input can be a good candidate.Example: parsing XML, JSON, txt, etc, upload data image, image, etc. So most of the steps will be the same only the handling of data will be changed. A sign-up process has a set of steps which can be fit into the template method. Provide Personal Information, User Interest and User Skills. Based on the user role each step can be modified here.‚ú® Trade-offsReusability vs FlexibilityTemplate pattern supports code reusability by moving common code in the base class. On the other hand, It creates a rigid hierarchy of classes. You cannot change the flow and steps in the derived class.For example, In the above case, The company want to introduce a Pizza with no cheese and no sauce (Healthy Pizza). There is no way to remove the steps here. However, in code, there is a way to achieve this by overriding the method and leaving it empty but then you break the Liskov substitute principle.Cohesion vs CouplingTemplate pattern helps to achieve cohesion in a code by grouping similar functionality in a single place. In the above case, getting feed for the application is at a single place and no dependency will exist on another module to get feeds if structure is followed.However, on the other hand, it creates a tight coupling between the base class and the subclasses. Any change in the base class will impact the derived class. While designing the base class you need to take care of the interface it should not be too fat.üåö FactsTemplate &amp; FactoryThe Template method may look like the Factory pattern as both have similar designs. However, the Factory pattern is a creational pattern and abstracts the creation logic of similar kinds of objects. On the other hand, a Template pattern is a behavioural design pattern which defines the behaviour of the process. Question: A template pattern which defines the behaviour of the creation of similar types of Objects can be called a Factory?Answer: Still, the Template pattern here helps to define the behaviour of the creation of an object not initialize an object for another module. The creation responsibility of the object is still outside of the template method.Template &amp; StrategyThe template method is used when a standard behaviour exists for a process. The standard behaviour is defined in the base class and variants in a standard behaviour can be added in the subclass.Strategy pattern is also used to handle multiple variants of a process. However, each variant has independent (No common) implementation. Sorting in most of the language is implemented through this pattern." }, { "title": "Game - Connect Balls", "url": "/posts/apps/apps-games-ConnectBall/", "categories": "Apps", "tags": "apps, game", "date": "2023-09-10 09:15:10 +0530", "snippet": "It is about:School time Memories are always there to cherish. Playing games on paper while the teacher is present in the classroom is what everyone remembers. This was one of the games I played mo...", "content": "It is about:School time Memories are always there to cherish. Playing games on paper while the teacher is present in the classroom is what everyone remembers. This was one of the games I played most of the time with friends. The game is simple yet engaging. You have to connect all the balls (dots on the paper) with a line. The line can be drawn with the use of a joystick.Let‚Äôs play all the levels and break the records !!!!.Download:Privacy Policy:Saurav Nagpal built the ConnectBalls app as a Free app. This SERVICE is provided by Saurav Nagpal at no cost and is intended for use as is.This page is used to inform visitors regarding my policies with the collection, use, and disclosure of Personal Information if anyone decided to use my Service.If you choose to use my Service, then you agree to the collection and use of information in relation to this policy. The Personal Information that I collect is used for providing and improving the Service. I will not use or share your information with anyone except as described in this Privacy Policy.The terms used in this Privacy Policy have the same meanings as in our Terms and Conditions, which are accessible at ConnectBalls unless otherwise defined in this Privacy Policy.Information Collection and UseFor a better experience, while using our Service, I may require you to provide us with certain personally identifiable information. The information that I request will be retained on your device and is not collected by me in any way.Log DataI want to inform you that whenever you use my Service, in a case of an error in the app I collect data and information (through third-party products) on your phone called Log Data. This Log Data may include information such as your device Internet Protocol (‚ÄúIP‚Äù) address, device name, operating system version, the configuration of the app when utilizing my Service, the time and date of your use of the Service, and other statistics.CookiesCookies are files with a small amount of data that are commonly used as anonymous unique identifiers. These are sent to your browser from the websites that you visit and are stored on your device‚Äôs internal memory.This Service does not use these ‚Äúcookies‚Äù explicitly. However, the app may use third-party code and libraries that use ‚Äúcookies‚Äù to collect information and improve their services. You have the option to either accept or refuse these cookies and know when a cookie is being sent to your device. If you choose to refuse our cookies, you may not be able to use some portions of this Service.Service ProvidersI may employ third-party companies and individuals due to the following reasons: To facilitate our Service; To provide the Service on our behalf; To perform Service-related services; or To assist us in analyzing how our Service is used.I want to inform users of this Service that these third parties have access to their Personal Information. The reason is to perform the tasks assigned to them on our behalf. However, they are obligated not to disclose or use the information for any other purpose.SecurityI value your trust in providing us your Personal Information, thus we are striving to use commercially acceptable means of protecting it. But remember that no method of transmission over the internet, or method of electronic storage is 100% secure and reliable, and I cannot guarantee its absolute security.Links to Other SitesThis Service may contain links to other sites. If you click on a third-party link, you will be directed to that site. Note that these external sites are not operated by me. Therefore, I strongly advise you to review the Privacy Policy of these websites. I have no control over and assume no responsibility for the content, privacy policies, or practices of any third-party sites or services.Children‚Äôs PrivacyI do not knowingly collect personally identifiable information from children. I encourage all children to never submit any personally identifiable information through the Application and/or Services. I encourage parents and legal guardians to monitor their children‚Äôs Internet usage and to help enforce this Policy by instructing their children never to provide personally identifiable information through the Application and/or Services without their permission. If you have reason to believe that a child has provided personally identifiable information to us through the Application and/or Services, please contact us. You must also be at least 16 years of age to consent to the processing of your personally identifiable information in your country (in some countries we may allow your parent or guardian to do so on your behalf).Changes to This Privacy PolicyI may update our Privacy Policy from time to time. Thus, you are advised to review this page periodically for any changes. I will notify you of any changes by posting the new Privacy Policy on this page.This policy is effective as of 2023-09-10Contact UsIf you have any questions or suggestions about my Privacy Policy, do not hesitate to contact me at nagpalsaurav@gmail.com.This privacy policy page was created at privacypolicytemplate.net and modified/generated by App Privacy Policy Generator" }, { "title": "ARC in Swift", "url": "/posts/ios/ios%20memory%20management/arc-in-swift/", "categories": "iOS, iOS Memory Management", "tags": "ARC, Swift ARC", "date": "2023-07-15 14:22:00 +0530", "snippet": "One of the key factors for the success of any application is its performance. Effective Memory Management in an application is crucial for better performance of the application. iOS applications de...", "content": "One of the key factors for the success of any application is its performance. Effective Memory Management in an application is crucial for better performance of the application. iOS applications developed using Swift language rely on ARC for tracking and managing application memory usage. ARC uses reference counting to manage the application memory.What is ARC?ARC is a memory management tool which tracks and manages the application memory. It is a compiler-driven feature. It observes the reference count of an object of a class to manage and free the memory. So the question is what is reference count?Reference count in simple language is the ‚Äúnumber of pointers to any object‚Äù. public typealias Amount = Int public class Trip { public var city: String public var totalSpending: Amount public init(city: String, totalSpending: Int) { self.city = city self.totalSpending = totalSpending } } //Uses of Trip Class let goaTrip = Trip(city: \"Panji\", totalSpending: 50000) //init is one pointer to Object of print(\"I spent Rs \\(goaTrip.totalSpending) in goa trip\") var tripToBeach = [goaTrip] // One more pointer to goaTrip var recentTrip = goaTrip // One more pointer to goaTrip print(\"I spent Rs \\(recentTrip.totalSpending) during recentTrip\")Reference counting only applies to class instances, so struct &amp; enum do not participate in reference counting.How ARC Works?As mentioned, ARC is a compiler-driven feature. It inserts retain and release statements during compilation. Retain - increase the reference count. Release - decrease the reference count.#TechShortsARC is the compiler-driven feature and it injects retain/release statements in a code during compilation time.How does the compiler decide when to insert retain/release? Object life cycle in Swift begins with init and ends at last use.ARC decide based on the above when to add retain and release statement. public typealias Amount = Int public class Trip { public var city: String public var totalSpending: Amount public init(city: String, totalSpending: Int) { self.city = city self.totalSpending = totalSpending } }The object life cycle in Swift is different from the other language. In most of the other languages, it ends at the closing brace.However, code should not be written based on this assumption as it might change with future compiler changes. For example, the following code is a good example of a team nightmare that suddenly a working code stopped. func explainWrongAssumptionUses() { //My trip List let goaTrip = Trip(city: \"Panji\", totalSpending: 50000) weak var weakRefrenceToGoaTrip = goaTrip if let strongRefrenceToGoaTrip = weakRefrenceToGoaTrip { print(\"I used weak reference here: Goa Trip Rs \\(strongRefrenceToGoaTrip.totalSpending) during the recent trip\") } }In the above case, it is wrong to assume that goaWeakTrip will always be there. The last use of the object is weak var weakRefrenceToGoaTrip = goaTrip and the compiler will insert release after this statement.So print statement here totally depends upon how the compiler works. if an Object‚Äôs life cycle in Swift begins with init and ends at last use. is strictly followed by the compiler then 50000 is the result. In the future, due to some drawbacks of this approach, Apple decided the scope based on the brace start and end then the result will be different.ARC need your help.ARC cannot detect or break **Reference cycle **. If object holds a strong reference to each other directly or indirectly in that case memory cannot be released of the objects.In the Direct case, the Trip and TravelDiary objects are strongly held together. Therefore, releasing one object requires the release of the other object as well. We can break the reference cycle here by making reference weak in the Trip object for the TravelDiary.In the Indirect case, the Person object is strongly held TravelDiary Object. TravelDiary strongly holds the trip object and further Trip holds the person object strongly. Therefore, releasing an Object in this scenario requires other two objects should be released. We can break the reference cycle here by keeping Person Object in the Trip object weak.Weak &amp; Unowned Reference CycleTo break the reference cycle weak and unowned keywords can be used. Both reference type does not participate in reference counting. public class TravelDiary { fileprivate var travels: [Trip] public init() { self.travels = [] } public func addTravel(_ travel: Trip) { self.travels.append(travel) } }Weak reference can be used when you are not sure about the life cycle of the referred object. It will automatically be set to nil if the object reference count becomes zero. The only constraint with weak is must be optional. public class Trip { public var city: String public var totalSpending: Amount public weak var travelDiary: TravelDiary? public init(city: String, totalSpending: Int) { self.city = city self.totalSpending = totalSpending } }Unowned reference can be used when you are sure about the life cycle of the referred object and it will not be deallocated. It can be used with an object which has an equal or greater life cycle. Unowned references can be declared as non-optional and faster access as compared to weak ones. The weak need to unwrap to access the value. public class Trip { public var city: String public var totalSpending: Amount public weak var travelDiary: TravelDiary? public init(city: String, totalSpending: Int) { self.city = city self.totalSpending = totalSpending } } let travelDiary = TravelDiary() //unowned uses let manaliTrip = Trip(city: \"Manali\", totalSpending: 40000, travelDiary: travelDiary) //weak uses let manaliTrip = Trip(city: \"Manali\", totalSpending: 40000) manaliTrip.travelDiary = travelDiary#TechShortsA weak reference is automatically set to nil if no strong reference remains and a weak reference is always optional. Unowned references will refer to deallocated memory if no strong reference remains, so the application can crash. Unowned is always non-optional.Bonus.There are safe ways to access the weak reference to avoid unexpected results or fatal exceptions (force unwrap) at run time. public class Trip { public var city: String public var totalSpending: Amount public weak var travelDiary: TravelDiary? public var isExistInTravelDiary: Bool { if let travelDiary = self.travelDiary { return travelDiary.travels.filter{ $0.city == self.city }.first != nil } return false } public init(city: String, totalSpending: Int) { self.city = city self.totalSpending = totalSpending } } public class TravelDiary { fileprivate var travels: [Trip] public init() { self.travels = [] } public func addTravel(_ travel: Trip) { self.travels.append(travel) } }Option 1: withExtendedLifetime func prepareTravelDiary() { //Manali Trip let travelDiary = TravelDiary() let manaliTrip = Trip(city: \"Manali\", totalSpending: 40000) manaliTrip.travelDiary = travelDiary travelDiary.addTravel(manaliTrip) withExtendedLifetime(travelDiary) { let existString = manaliTrip.isExistInTravelDiary ? \"exist\": \"not exist\" print(\"Manali Travel \\(existString) in Travel Diary\") } }Option 2: Strong Reference Capture func prepareStrongTravelDiary() { //Manali Trip let travelDiary = TravelDiary() let manaliTrip = Trip(city: \"Manali\", totalSpending: 40000) manaliTrip.travelDiary = travelDiary travelDiary.addTravel(manaliTrip) processTrip(manaliTrip) } func processTrip(_ trip: Trip) { //somewhere in code in other method if let travelDiary = trip.travelDiary { let existString = trip.isExistInTravelDiary ? \"exist\" : \"not exist\" print(\"\\(trip.city) Travel \\(existString) in Travel Diary\") } }" }, { "title": "Distribute iOS Beta Build (Scheme & Configurations)", "url": "/posts/ios/ios%20beta%20build/iOS-Custom-Build-Scheme/", "categories": "iOS, iOS Beta Build", "tags": "iOS scheme, iOS build config", "date": "2023-07-02 17:01:10 +0530", "snippet": "üåë OutlineHaving multiple build configurations during the application‚Äôs development phase is a good practice. Customers can ask for both debug and release configuration builds. Beta and Alpha testin...", "content": "üåë OutlineHaving multiple build configurations during the application‚Äôs development phase is a good practice. Customers can ask for both debug and release configuration builds. Beta and Alpha testing is an important phase of the application life cycle. Beta and Alpha builds might have different configurations from the release build. This blog explains one of the ways to handle this through an Xcode scheme.üå•Ô∏è Why SchemeSuppose you are working on an e-commerce application ShopTime. In the development phase, multiple backend environments need to support (Dev, QA, UAT, Release). The customer provides separate application icons to differentiate between the application build (Development, QA, Beta builds, etc.). These builds also have a unique bundle ID. The launch screens should also be different for each build so that users can easily identify the build. Configuration can support multiple features however for this blog we will focus on the following: Bundle Identifier App Icon Launch Screen Backend URL üåì How To CreateXcode supports multiple configurations in a single target. By default, Xcode provides debug and release configuration. Let‚Äôs start step by step the process:‚ö° Add a new configuration (Beta configuration)¬†¬†¬†¬†¬†¬†¬†¬† i) Navigate to the project setting¬†¬†¬†¬†¬†¬†¬†¬† ii) Tap on the ‚Äú+‚Äù button in the configuration section and duplicate the debug configuration(you can choose duplicate of release based on requirement). ¬†¬†¬†¬†¬†¬†¬†¬† iii) Enter the name of the configuration (BetaDebug). ‚ö° Change product bundleid for BetaDebug¬†¬†¬†¬†¬†¬†¬†¬† (i) Move to Target-&gt; Build Setting-&gt; Search(Product Bundle Identifier)¬†¬†¬†¬†¬†¬†¬†¬† (ii) Set the bundle identifier as per your requirement. ‚ö° Set a separate application icon for BetaDebug¬†¬†¬†¬†¬†¬†¬†¬† i) Add a new AppIcon asset in Assets with a specific name(AppIconBeta).¬†¬†¬†¬†¬†¬†¬†¬† ii) Add AppIconBeta in the BetaDebug configuration.¬†¬†¬†¬†¬†¬†¬†¬† iii) Finally!, a separate application icon is set for BetaDebug.‚ö° Set separate Launch screen for BetaDebug¬†¬†¬†¬†¬†¬†¬†¬† i) Add a new launch screen for Beta config. ¬†¬†¬†¬†¬†¬†¬†¬† ii) Edit launch screen configuration for BetaDebug.¬†¬†¬†¬†¬†¬†¬†¬† iii) Finally!, a separate Launch screen is set for BetaDebug.‚ö° Add a user setting for the backend URL¬†¬†¬†¬†¬†¬†¬†¬† (i) Add a new user-defined setting in the target setting. ¬†¬†¬†¬†¬†¬†¬†¬† ii) Name the configuration ‚ÄúBackend_URL‚Äù(choose your own name) and change the URL string for BetaConfig.¬†¬†¬†¬†¬†¬†¬†¬† iii) Add the entry in info.plist for the backend URL.¬†¬†¬†¬†¬†¬†¬†¬† iv) Fetch the user-defined setting in the code.if let urlString = Bundle.main.object(forInfoDictionaryKey: \"Backend URL\") as? String { print(urlString)}üåï Where to use‚ö° It can be used to handle code signing variation in the application build type like beta build, ad-hoc build, test build, etc. Each scheme will represent a building type. ‚ö° It can be used to add configurations with respect to builds like backend URLs, API keys, etc.üåö Facts‚ö° Application Target is different from the scheme. A target may have multiple schemes. A target can be used to make variants of the application like pro features (No ads, offers)." }, { "title": "Simplify Decorator Pattern (Structure Pattern)", "url": "/posts/design%20pattern/clean%20code/decoratorpattern/", "categories": "Design Pattern, Clean Code", "tags": "Decorator Pattern, Class Wrapper", "date": "2023-06-24 20:00:10 +0530", "snippet": "üåë OutlineThe decorator pattern adds new functionality to an existing object without changing its structure. A wrapper on the existing object is created to add new functionality. Template - Decorat...", "content": "üåë OutlineThe decorator pattern adds new functionality to an existing object without changing its structure. A wrapper on the existing object is created to add new functionality. Template - Decorator Pattern - Decorate an object (wrapper of an object).üå•Ô∏è Why DecoratorOne day our customer sent an email that he required one more analytics tool to be integrated into the application. We already have the Firebase analytic tool in the application. The reason mentioned by the customer to add a new analytic tool is that it provides good support with their BI Tool.The team checked the current implementation. The current implementation has an analytics event controller class which accepts an event object and sends the same to the Google Analytics framework.One quick common approach all the team members have is to add support for Adobe Analytics in the Analytic controller, so when the developer sends analytics from any screen it will by default capture both frameworks (Firebase, Adobe Analytics).With this approach, the Analytic Controller code will become bloated. If there is a new requirement to add a new type of analytics, then it will not be easy to accommodate in the controller.We brainstormed more on this so that the Analytic Controller would not be overburdened in future and then the decorator came into the picture.üåõ = üåú MetaphorAdding topping to the Pizza base can related to the decorator. If you are preparing Tomato Pizza then you will put Tomato on the base. If you add the vegetable on the base then it is a vegetable Pizza.So based on topping on the Pizza base behaviour is changed and taste also :).üåì Talk is cheap. Show me the code‚ö° Create an interface with the required methods.‚ö° Create a concrete class implementing the basic behaviour in it.‚ö° Create a decorator class implementing the same interface and also implement the add-on behaviour in it.‚ö° The decorator class should also hold a strong reference to the base class and call the base class method first.Code SnippetAn analytic event is a struct which will hold an analytic event and an Analytic Delegate is protocol.struct AnalyticEvent { let eventName: String var eventDetail: [String: String]}protocol AnalyticDelegate { func sendEvent(_ event: AnalyticEvent)}//Firebase Analyticsimport Firebaseclass AnalyticController: AnalyticDelegate { init() { FirebaseApp.configure() } func sendEvent(_ event: AnalyticEvent) { Analytics.logEvent(event.eventName, parameters:event.eventDetail) }}//Class Implementation before Decoratorclass AddToCartController { let analyticDelegate: AnalyticDelegate init(analyticDelegate: AnalyticDelegate = AnalyticController()) { self.analyticDelegate = analyticDelegate } func startPayment(for product: Product, paymentMethod: SupportedPaymentFacade) { let paymentInfo = PaymentInfo(skuID: product.skuID, amount: product.amount, method: paymentMethod) facade.doPayment(paymentInfo) }}//Decorator class implements the Adobe Analytics and delegates firebase event to the existing controller.class AnalyticControllerDecorator: AnalyticDelegate { let analyticDelegate: AnalyticDelegate init(analyticDelegate: AnalyticDelegate = AnalyticController()) { self.analyticDelegate = analyticDelegate } func sendEvent(_ event: AnalyticEvent) { MobileCore.track(action: event.eventName, data: event.eventDetail) self.analyticDelegate.logEvent(event.eventName, parameters:event.eventDetail) }}//Class Implementation before Decoratorclass AddToCartController { let analyticDelegate: AnalyticDelegate init(analyticDelegate: AnalyticDelegate = AnalyticController()) { self.analyticDelegate = analyticDelegate } func startPayment(for product: Product, paymentMethod: SupportedPaymentFacade) { let paymentInfo = PaymentInfo(skuID: product.skuID, amount: product.amount, method: paymentMethod) facade.doPayment(paymentInfo) }}//Uses with or without Decoratorvar controllerWithFirebaseAnalytic = AddToCartController(AnalyticController())var controllerWithFirebaseAnalytic = AddToCartController(AnalyticControllerDecorator())‚ú® Trade-offsFlexibility vs UsabilityIt provides the flexibility of adding new functionality at run time. Also, you can mix &amp; match the new functionalities by creating n number of classes. However, you cannot remove any decorator from the sequence of execution without writing any custom logic in the decorator.Flexibility vs ReadabilityIt may also lead to many tiny objects in your code none of which do anything on their own. It will be very difficult to understand for a new developer and debug any issue.For example: if you need to support 3 different analytics tools based on the configuration then you might end up minimum of 4 small classes.üåï Applicability‚ö° Use the decorator when you need to add additional behaviour to an existing object without impacting the current uses of the object.‚ö° The decorator object and main objects share a common interface so both can be used interchangeably. In this way, existing applications can use additional business requirements with minimal changes.‚ö° Additional behaviour is required on the final class without changing anything on an existing object.‚ö° The decorator object and main objects share a common interface so both can be used interchangeably. In this way, existing applications can use additional business requirements with minimal changes. You can create decorators on the UIView/SwiftUI View to display borders, rounded corners, add background views, etc.üåö FactsInheritance &amp; Decorator‚ö° Where inheritance only works for similar kinds of objects but decorator can be used on objects with a common interface.‚ö° Classes with final behaviour. In those cases, inheritance is not possible. so we can use a decorator pattern to add additional behaviour.‚ö° Decorator applies to only a single object of a class. However, inheritance applies to the entire class.‚ö° Use inheritance when you need additional behaviour on non-public members of the class.Adapter vs Decorator‚ö° An adapter pattern also holds an object and provides a simplified interface (familiar Interface) to the outer world for that object.‚ö° Adapter Object does not provide an additional behaviour on the object.‚ö° In the adapter case, the client (who calls the method) is unaware of the object interface. It only knows the Adapter interface." }, { "title": "Simplified Facade Pattern (Structure Pattern)", "url": "/posts/design%20pattern/clean%20code/Facadepattern/", "categories": "Design Pattern, Clean Code", "tags": "Facade Pattern, Face of a building", "date": "2023-06-24 20:00:10 +0530", "snippet": "üåë OutlineA pattern to provide a simple interface to a complex framework or library. It hides the complexity and interaction between different objects in the framework. Facade - Face of a building....", "content": "üåë OutlineA pattern to provide a simple interface to a complex framework or library. It hides the complexity and interaction between different objects in the framework. Facade - Face of a building.üå•Ô∏è Why FacadeSuppose you are working on an e-commerce application. You have to support multiple payment options like UPI, Credit card, Debit Card, Wallet etc. You have chosen a third-party payment gateway which provides support for all types of payments. The payment gateway has an initiation setup (API key, session) and multiple objects for payment methods.If you write all the logic in your application class then your class object is required to manage all the payment objects and track the life cycle of those objects. In this way, your code will be tightly dependent upon third-party payment SDK.To make things simple we can use here Facade Design Pattern.üåõ = üåú MetaphorA desktop computer on your table is a good example of a facade pattern. You just need to press the power button and everything is behind-the-scenes. The power supply sends electricity to all components and then initializes the BIOS, Load instructions from ROM, etc.All these complex tasks happen secretly and the person sitting in front just has a single interface a Power button :).üåì Talk is cheap. Show me the codeIn the Facade pattern, a class is created to provide a simple interface for a complex system.Code Snippet//Enum to identify payment type.enum SupportedPaymentFacade { case wallet case upi case card}//Payment Information.struct PaymentInfo { let skuID: String let amount: Int let method: SupportedPaymentFacade}// sample class which represent the complex third party frameworkclass PaymentSDKUmbrella { let walletSDK: PSWallet let upiSDK: PSUPI let cardSDK: PSCard}// Facade class application interact with this object. Application will not aware about PaymentSDKUmbrella.class PaymentFacade { var paymentSDKUmbrella: PaymentSDKUmbrella? func doPayment(_ paymentInfo: PaymentInfo) { switch paymentInfo.method { case .card: cardSDK.doPayment(paymentInfo.amount) case .upi: upi.doPayment(paymentInfo.amount) case .wallet: if walletSDK.hasSufficientAmount(paymentInfo.amount) { walletSDK.doPayment(paymentInfo.amount) } else { print(\"Insufficient balance\") walletSDK.addPayment(paymentInfo.amount) } } }}//Application uses of facade classclass AppPaymentController { let facade = PaymentFacade() func startPayment(for product: Product, paymentMethod: SupportedPaymentFacade) { let paymentInfo = PaymentInfo(skuID: product.skuID, amount: product.amount, method: paymentMethod) facade.doPayment(paymentInfo) }} ApplicabilityComplex LibraryIntegrating a library which has multiple subsystems can be done through the facade pattern. Also, if the library is used at multiple places then to avoid the redundant code of init and setup the library facade can be used. In the above example, payment SDK has multiple sub-systems like wallet, net banking and Card payment. So you can create a facade class in a way that your application has minimal knowledge of all the dependencies of the payment SDK.Small InterfacesUse a facade pattern when you want to use limited functionality from a complex library. In the case of payment SDK, if you want to use only wallet and card payment in your application then you can create a facade class to support only those features. FactsAdapter vs Facade Pattern The facade provides a new interface to interact with a complex framework. However, the adapter fits the new object in the existing interface. An adapter or wrapper pattern is usually for a single object. However, Facade also interacts with multiple objects.Mediator vs Facade Pattern The mediator class is used for providing the interaction between sub-components. However, the facade class is used for providing access (simple interface) to sub-components of a large component. In the case of the mediator, sub-components are aware of the mediator class but the facade class is only visible to the application using sub-components. AdvantagesYou must have been feeling now that the use of the facade pattern is just that the responsibility of interaction to complex system is shifted to facade class. DecouplingIt is always considered good practice that your application code should not directly depend upon the third-party library interface. Facade patterns provide a simple interface to a complex framework, in a way you also achieve decoupling here. Like in the above case your application code depends upon the Facade class, so if in the future library code changes then only the Facade class will be impacted.ReusabilityIn some use cases, the same library needs to be used from multiple places. Like in the above case payment can be done from multiple screens, so instead of the user accessing the library code at each screen the facade class can be used which also reduces the library setup/init burden at every place.ReadabilityMost of the time library/framework code is legacy code. Coding convention changes from time to time and the library interface might not fit your current coding convention, So the facade can be used to make code consistent in your application." }, { "title": "Flutter on Apple Silicon Mac: Cocoa-pods Issue", "url": "/posts/crossplatform/flutter/crossplatform-Flutter-on-Apple-Silicon-Mac/", "categories": "CrossPlatform, Flutter", "tags": "Mac rosetta, Mac M1", "date": "2023-06-22 09:15:10 +0530", "snippet": "Step 1:Flutter requires the rosette must be installed on your machine. Rosetta is a translation library which allows users to run apps that contain X86_64 instructions on Apple silicon Mac.sudo sof...", "content": "Step 1:Flutter requires the rosette must be installed on your machine. Rosetta is a translation library which allows users to run apps that contain X86_64 instructions on Apple silicon Mac.sudo softwareupdate --install-rosetta --agree-to-licenseStep 2:Cocoa-pods require a terminal using UTF-8 encoding. Sometimes only setting ‚ÄúLANG=en_US.UTF-8‚Äù not works. you need to perform the following steps: Open Terminal nano ~/.zshrc (\"or nano ~/.profile if you don't use zsh\") Apeen the following in the editor:export LANG=en_US.UTF-8export LANGUAGE=en_US.UTF-8export LC_ALL=en_US.UTF-8 Save the file and quit the terminal. Open the file again and verify.Step 3 (Optional)if you still see an error related to ‚Äúffi‚Äù then reinstall the gem ‚Äúffi‚Äù in the system with the following command.sudo gem uninstall ffi &amp;&amp; sudo gem install ffi -- --enable-libffi-alloc" }, { "title": "Swift ?? (Nil Coalescing) Do's and Don't", "url": "/posts/swift/swift%20safety/Swift-(Nil-Coalescing)-Do's-and-Don't/", "categories": "Swift, Swift Safety", "tags": "Swift optional, Swift Nil Coalescing", "date": "2023-06-21 02:24:10 +0530", "snippet": "What is it?Optional is one of the fundamental safety features provided in Swift. It is a container for a value of a particular type. We are using the term container here because it means it may con...", "content": "What is it?Optional is one of the fundamental safety features provided in Swift. It is a container for a value of a particular type. We are using the term container here because it means it may contain a value or not. Nil coalescing ?? is an operator used to provide a default if the optional is empty.How to use it?Add default value after the ?? operator following Optional. var name: String? let displayName = name ?? \"NA\" print(\"name is:\\(displayName)\")In this case, if the name is not available then ‚Äúname is NA‚Äù will be printed. In Swift, we need to always take care while unwrapping an Optional as it might crash the application. The Nil coalescing ?? operator does the Job for you if it finds the optional has no value then it uses a default instead.Do‚Äôs and Don‚Äôt with ?? (#My Opinion)Following are some of the uses I have seen in the code and we go through them one by one and discuss the case:(i) Requirement is if Name is not present then display ‚ÄúNA‚Äù var name: String? let displayName = name ?? \"NA\" print(\"name is:\\(displayName)\")(ii) Requirement is to get number of rows in the selected section func indexPathOfTableView() { var selectedIndexPath: IndexPath? //Assing a value in code somewhere selectedIndexPath = IndexPath(section: 1, row: 0) //Uses of the indexPath tableView?.numberOfRows(inSection: selectedIndexPath?.section ?? 0) }(iii) Requirement is to fetch a random student from the list func randomStudent() { var randomStudent: Student? //Assign Value to the random student in code //Somewhere in code let selectedStudent = randomStudent ?? Student() if selectedStudent.name.count &gt; 0 { } }(iv) Requirement is to fetch all student names. struct Student { var name: String } func fetchAllNames() { var students: [Student]? //All student Name let studentNames = students?.map { $0.name ?? \"\" } print(\"All Student Names:\\(studentNames)\") }(v) Requirement is to check if the student list exists or not. func checkStudentExist() -&gt; Bool { var students: [Student]? //check student exist if students?.count ?? 0 &gt; 0 { return true } return false }My Opinion(i) Do - It is correct usage as we provide the default value if it does not exist.(ii) Don‚Äôt - 0 is not the default value for the section and it also can cause an unexpected issue If the index path in any case nil.(ii) Don‚Äôt - In this case, a student object without referring to any student is not a correct usage it is not a default value. It can cause an issue or crash if you are expecting a real object and get this value.(iv) Don‚Äôt - The requirement is to fetch all names of a student and in case the student does not exist in the record then you should not assign a default value like ‚Äú‚Äù. Either you have some agreed default value or raise an exception name not exist.(v) Don‚Äôt - The requirement is to check if the student list exists or not. In the case of the, if students?.count ?? 0 &gt; 0 condition using the default value is reducing the condition. However, in my opinion, it reduces the readability." }, { "title": "Game - Save Trees", "url": "/posts/apps/apps-games-SaveTrees/", "categories": "Apps", "tags": "Game, Apps", "date": "2022-08-22 09:15:10 +0530", "snippet": "It is about:Mowgli everyone‚Äôs childhood hero is on a mission to save trees. This time, the enemy is not Shere Khan Humans are coming to destroy the Jungles. Mowgli needs to block their path by digg...", "content": "It is about:Mowgli everyone‚Äôs childhood hero is on a mission to save trees. This time, the enemy is not Shere Khan Humans are coming to destroy the Jungles. Mowgli needs to block their path by digging a hole. Mowgli can plant new trees to revive the Jungle.Download:" } ]
